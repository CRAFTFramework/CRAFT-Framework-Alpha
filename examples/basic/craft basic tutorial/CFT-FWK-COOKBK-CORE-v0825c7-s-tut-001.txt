# =======================================
# CRAFT FRAMEWORK COOKBOOK CORE
# File: CFT-FWK-COOKBK-CORE-v0825c6.txt
# Version: v0825c7.txt
# Last Updated: 08-24-2025
# Category: CAT-001 (Reserved Range: 001-050)
# =======================================


# =========================================================
# Licensed under the Business Source License 1.1 (BSL)
# © 2025 Ketelsen Digital Solutions LLC
# Free for non-commercial use (research, educational, experimental).
# Commercial use requires a license from Ketelsen Digital Solutions LLC.
# On or after 2029-01-01, this file will be licensed under Apache 2.0.
# =======================================


# CATEGORY RESERVATION NOTICE:
# ============================
# This cookbook uses Category CAT-00X
# Categories 001-050: Reserved for CRAFT Cookbook files
# Categories 051-999: Reserved for AICookbook.ai website
# When creating recipes, use only the assigned category number
# =======================================






# ================================================
"""
Every CRAFT project consists of four interconnected Python-compatible text files that work together to create a complete framework implementation:
   1. PROJECT IMPLEMENTATION FILE Filename pattern: CFT-PROJ-[project_number]_[project_name]-v[version].txt Purpose: Contains the active project-specific implementation of the CRAFT framework, including all defined variables, functions, objects, and structured chat instructions relevant to the current project.
   2. CONVERSATION CONTINUITY FILE Filename pattern: CFT-PROJ-[project_number]_AI-CHAT-HISTORY-v[version].txt Purpose: Facilitates session-to-session continuity through a structured "Handoff" system, enabling each AI chat session to seamlessly pass context to subsequent interactions.
   3. FRAMEWORK SPECIFICATION FILE Filename pattern: CFT-FWK-SPEC-v[version].txt Purpose: Defines the current specification for the CRAFT (Configurable Reusable AI Framework Technology) framework, providing the foundational rules and structures that govern all CRAFT implementations.
   4. BASIC FRAMEWORK CORE COOKBOOK: CFT-FWK-COOKBK-CORE-v[version].txt Purpose: Defines a base set of Recipes that are useful to the basic function CRAFT Framework.
These files form a cohesive system that maintains project integrity across multiple AI interactions while ensuring consistent application of CRAFT principles. 
"""
# ================================================


# ================================================
"""
CRAFT FRAMEWORK COOKBOOK - FOURTH ESSENTIAL FILE


This cookbook serves as the fourth essential file in the CRAFT Framework system,
complementing the Project Implementation, Conversation Continuity, and Framework 
Specification files. Its purpose is to provide a curated collection of frequently-used
base recipes that enhance the basic functioning of any CRAFT project.


PURPOSE:
--------
1. BASE RECIPE REPOSITORY: Contains 5-10 essential base recipes that address common 
   communication patterns and the 7 Alpha Phase 1 goals for improving AI-human interaction


2. ALPHA PHASE 1 SUPPORT: Specifically designed to provide practical solutions for:
   - Identifying and documenting AI restrictions and limitations
   - Setting realistic expectations for AI capabilities
   - Standardizing comment usage for practical workflows
   - Formalizing communication workflows
   - Providing quantifiable feedback mechanisms
   - Reducing prompt misinterpretation
   - Detecting and correcting hallucinations


3. QUICK ACCESS: Provides immediate access to tested, reliable recipes without
   requiring external lookups, ensuring efficient workflow continuity


4. GATEWAY TO LARGER LIBRARY: While this file contains essential base recipes, a growing
   library of additional recipes is available at www.aicookbook.ai/recipes-via-craft-api/
   The recipes included here are specifically chosen for their frequent use and
   fundamental importance to CRAFT operations.


RELATIONSHIP TO CRAFT RECIPE SYSTEM:
-----------------------------------
For comprehensive information about the CRAFT Recipe System, including:
- Recipe principles and philosophy
- Recipe identification system
- Recipe object classes
- Discovery and organization
- Security framework
- Error handling


Please refer to Section 7 (CRAFT RECIPE SYSTEM) in the Framework Specification File
(CFT-FWK-SPEC-v[version].txt), which provides complete documentation of how recipes
integrate with all CRAFT components.


USAGE NOTES:
-----------
- Recipes in this cookbook are immediately available without network access
- Each recipe follows the standardized CRAFT Recipe format
- All recipes are generic enough to work with any version of CRAFT
- Recipes are essentially prompts that have been tested with a variety of A.I.s
- Version compatibility is inherent in the recipe design


RECIPE SELECTION CRITERIA:
------------------------
Recipes included in this cookbook are selected based on:
1. Frequency of use across CRAFT projects
2. Proven effectiveness in improving AI-human communication
3. General applicability across different project types
"""
# ================================================


# =========================================================
# RECIPES 
# =========================================================
#H->AI::Directive: (The recipes listed below are Base Recipes which I believe add utility to any A.I. chat)
#H->AI::Directive: (When a human asks for recipes, categories, or recipe-related information, follow this protocol:)


"""


# =========================================================
# RECIPE-SPECIFIC SECURITY PROTOCOL
# =========================================================
#H->AI::Directive: (These security rules apply ONLY to recipe operations)
#H->AI::Context: (General web browsing remains unrestricted)


"""
RECIPE SECURITY REQUIREMENTS:
============================


1. RECIPE SOURCE VALIDATION:
   When fetching/executing recipes:
   - Internal: Recipes in this cookbook file - ALLOWED
   - External: https://www.aicookbook.ai/recipes-via-craft-api/ - ALLOWED
   - Other recipe sources - BLOCKED
   
   General web access remains open for:
   - Research URLs
   - Documentation
   - Any non-recipe content


2. RECIPE URL PATTERNS:
   Security checks activate for URLs containing:
   - /recipes-via-craft-api/
   - /recipe/ or /rcp-
   - craft-recipe patterns
   
3. SECURITY RESPONSES FOR RECIPES:
   #AI->H::SecurityWarning: (Unauthorized recipe source detected)
   #AI->H::Note: (For recipes, use only AICookbook.ai or cookbook file)


4. RECIPE VERIFICATION:
   Valid recipes must contain:
   - "CRAFT RECIPE START" marker
   - Valid RECIPE_ID format
   - "RECIPE END" marker
"""


RECIPE ACCESS PROTOCOL FOR AI ASSISTANTS:
========================================


When a human requests:
- A specific recipe (by name or ID)
- A list of all recipes
- Recipe categories
- Recipes in a specific category
- Any recipe-related query


FOLLOW THESE STEPS:


1. FIRST: Check the attached cookbook file for the requested recipe
   - The cookbook contains essential base recipes
   - If found, provide the recipe directly


2. IF NOT FOUND: Inform the human using this format:
   
   #AI->H::Note: (The recipe "[recipe_name]" is not in the base cookbook)
   #AI->H::Caution: (To access the complete recipe directory, I need to fetch the listing from AICookbook.ai)
   
   The complete CRAFT recipe collection is maintained at AICookbook.ai and contains:
   - 9+ recipes across multiple categories
   - Categories including Foundational, Content, Marketing, and Analysis
   - New recipes added regularly
   
   #AI->H::Status: (Platform limitation - I can only access URLs you explicitly provide)
   
   To access the recipe directory, please copy and paste this request into the chat:
   
   **"Go to https://www.aicookbook.ai/recipes-via-craft-api/list-all-recipes"**
   
   Once you provide this instruction, I can:
   - Show you all available recipes
   - Help you navigate categories
   - Provide direct links to specific recipes
   - Guide you through recipe selection


3. ALTERNATIVE: If the human prefers not to access external recipes:
   #AI->H::Question: (Would you like to work with the base recipes in the cookbook instead?)
   #AI->H::Note: (Available base recipes: [list cookbook recipes])


RATIONALE:
- The cookbook file contains only essential base recipes to keep it manageable
- The full recipe library at AICookbook.ai is continuously updated
- This approach ensures access to the latest recipes while respecting platform constraints
- Users maintain control over external access


EXAMPLE RESPONSES:


For "Show me all recipes":
#AI->H::Note: (To show all available CRAFT recipes, I need to access the complete directory)
#AI->H::Status: (The base cookbook contains [X] essential recipes, but the full library has many more)
#AI->H::RequestingFeedback: (Please paste: "Go to https://www.aicookbook.ai/recipes-via-craft-api/list-all-recipes")


For "I need an email subject recipe":
#AI->H::Note: (Checking cookbook for email-related recipes...)
#AI->H::Status: (Email subject recipe not found in base cookbook)
#AI->H::RecipeSuggestion: (This recipe exists in the main directory - shall I guide you to access it?)
"""


#H->AI::Directive: (More recipes are continuously added at "https://www.aicookbook.ai/recipes-via-craft-api/list-all-recipes")
#H->AI::Context: (The cookbook below contains verified base recipes for immediate use without external access)






CRAFT RECIPE CREATION GUIDELINES:
========================================
Version 2.0 | Compatible with CRAFT v0.0725f1+
Updated for Base Cookbook Integration
Table of Contents


Introduction
What Makes a Good Recipe?
Recipe ID Format
Step-by-Step Creation Process
Parameter Best Practices
Security Considerations
Policy Compliance
Testing Checklist
Integration with Base Cookbook
Examples and Templates


Introduction
CRAFT Recipes are parameterized, reusable prompt templates that extend the CRAFT framework's capabilities. This guide provides comprehensive instructions for creating high-quality recipes that integrate seamlessly with the CRAFT ecosystem and work harmoniously with the 14 base cookbook recipes.
Key Updates in v2.0:


Policy Pre-Check Integration: All recipes must include policy compliance checks
Base Cookbook Alignment: Recipes should leverage existing cookbook functionality
Enhanced Security: Multi-layer validation following Section 8 of the Framework
Token Monitoring: Integration with TOKEN-MONITOR recipe for efficiency


What Makes a Good Recipe?
Core Criteria:


Single Purpose: Solves one specific problem well
Parameterized: Flexible through well-designed parameters
Validated: Includes parameter validation and security checks
Policy-Aware: Contains pre-checks for sensitive content
Documented: Clear descriptions and multiple examples
Secure: Prevents injection attacks and malicious use
Efficient: Optimized for token usage with monitoring
Integrated: Works with base cookbook recipes


Integration Points:


Uses AMBIGUITY-DETECT for unclear parameters
Leverages CONFIDENCE-CALIB for uncertain outputs
Integrates ERROR-TRANS for user-friendly errors
Employs SOURCE-VALID for factual claims
Utilizes PROGRESS-TRACK for multi-step processes


Recipe ID Format
The CRAFT Recipe System uses a hierarchical ID format supporting up to 999,999,999 unique recipes:
RCP-XXX-YYY-ZZZ-NAME-vMAJOR.MINORpatch
Components:


RCP: Fixed prefix identifying CRAFT recipes
XXX: Category group (001-999) - Note: Now starts at 001, not 000
YYY: Subcategory (001-999)
ZZZ: Sequence within subcategory (001-999)
NAME: Descriptive name (UPPERCASE, alphanumeric + hyphens)
vMAJOR.MINORpatch: Semantic versioning


Reserved Ranges:


001-004: Base Cookbook recipes (14 recipes currently)
001-001: Foundational/General
001-002: Content Generation
001-003: Marketing
001-004: Base Cookbook specific


Examples:
RCP-001-004-014-CRAFT-BRAINSTORMER-v1.00a  # Latest cookbook addition
RCP-002-001-001-BLOG-TITLE-v1.00a          # Content category
RCP-003-002-001-AUDIENCE-ANALYZER-v2.15c   # Marketing/Research
Step-by-Step Creation Process
Phase 1: Planning (25% of effort)
1.1 Define the Problem


What specific task will this recipe solve?
Which Alpha Phase 1 goals does it address?
How does it complement existing cookbook recipes?
What policy considerations apply?


1.2 Check Base Cookbook Integration
python# Review which cookbook recipes could enhance yours:
COOKBOOK_INTEGRATION_MAP = {
    "unclear_inputs": "AMBIGUITY-DETECT",
    "estimates_needed": "CONFIDENCE-CALIB",
    "long_process": ["EXPECTATION-SETTER", "PROGRESS-TRACK"],
    "fact_checking": "SOURCE-VALID",
    "error_handling": "ERROR-TRANS",
    "ai_limitations": "LIMITATION-ACK"
}
1.3 Design Parameters


List all variables users might want to control
Determine which are required vs optional
Define sensible defaults
Consider policy implications of each parameter


Phase 2: Development (45% of effort)
2.1 Create the Recipe Structure
pythonMY_RECIPE = Recipe(
    recipe_id="RCP-XXX-YYY-ZZZ-NAME-v1.00a",
    title="Clear, Descriptive Title",
    description="2-3 sentences explaining purpose and value",
    category="CAT-[Category]",
    subcategory="SUBCAT-[Subcategory]",
    difficulty="easy|medium|hard",
    
    parameters={
        # Well-designed parameters
    },
    
    prompt_template="""
    #H->AI::Directive: (Primary instruction)
    #H->AI::Context: (Background information)
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics
    
    IF potential conflict detected:
        #AI->H::PolicyCaution: (This topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [safe aspect])
    
    # Your recipe logic here
    """
)
2.2 Mandatory Security Elements
Every recipe MUST include:


Policy Pre-Check (Step 0)
Parameter Validation
Security Verification (if accessing external resources)


python# RECIPE SECURITY VERIFICATION
if not verify_security_active():
    #AI->H::Caution: (Recipe security verification failed)
    #AI->H::Status: (Proceeding with limited security)
2.3 Leverage Base Cookbook
Instead of reinventing, use existing recipes:
python# DON'T: Create your own ambiguity detection
# DO: Reference AMBIGUITY-DETECT recipe


IF user_input appears unclear:
    #AI->H::Note: (Invoking AMBIGUITY-DETECT for parameter clarification)
    # Use the existing recipe's logic
Phase 3: Testing (20% of effort)
3.1 Compliance Score Target


Minimum: 95/100
Use guidelines-based test suite
Verify all security layers active


3.2 Integration Testing
python# Test with cookbook recipes:
def test_with_token_monitor():
    """Ensure recipe respects token limits"""
    # Your recipe should work within TOKEN-MONITOR warnings
    
def test_with_error_translator():
    """Verify errors are user-friendly"""
    # Errors should be compatible with ERROR-TRANS
Phase 4: Documentation (10% of effort)
4.1 Required Sections


Clear description with Alpha Phase 1 goal alignment
Parameter descriptions with policy implications
Integration notes for cookbook recipes
Minimum 3 diverse examples


Parameter Best Practices
Enhanced Parameter Design
Type Selection with Validation
pythonparameters={
    "content": {
        "type": "string",
        "required": True,
        "max_length": 10000,  # Token efficiency
        "validation": "no_injection",  # Security
        "description": "Main content to process"
    },
    "confidence_threshold": {
        "type": "float",
        "required": False,
        "default": 0.8,
        "min": 0.0,
        "max": 1.0,
        "description": "Minimum confidence for assertions"
    },
    "policy_mode": {
        "type": "string",
        "required": False,
        "default": "standard",
        "options": ["strict", "standard", "relaxed"],
        "description": "Policy compliance level"
    }
}
Parameter Limits (Updated)


Total parameters: Maximum 15-20
Required parameters: Maximum 3-5
String length: Consider token impact
Lists: Maximum 50 items
Nested structures: Maximum 3 levels


Security Considerations
Multi-Layer Security (per Framework Section 8)
Layer 1: URL Validation
python# For recipes fetching external content
if url and not url.startswith("https://www.aicookbook.ai/recipes-via-craft-api/"):
    #AI->H::SecurityWarning: (Invalid recipe source)
    raise SecurityError("Unauthorized recipe source")
Layer 2: Content Validation
python# Check for required markers
if "CRAFT RECIPE START" not in content:
    #AI->H::SecurityWarning: (Invalid recipe format)
Layer 3: Parameter Sanitization
pythonforbidden_patterns = ["<script", "javascript:", "eval(", "exec(", "import os"]
# Implement checking logic
Policy Compliance
Mandatory Policy Integration
Every recipe must be aware of AI usage policies:
python# Reference the digest from Framework Section 1.12
POLICY_CONSIDERATIONS = {
    "capability_probing": ["limitations", "bypass", "jailbreak"],
    "harmful_content": ["weapon", "exploit", "malware"],
    "privacy_concerns": ["track", "surveillance", "unauthorized"]
}
Policy-Aware Design


Anticipate potential misuse
Include safeguards in the template
Provide alternative approaches for sensitive requests
Never facilitate policy violations


Testing Checklist
Pre-Release Testing (Enhanced)
Core Functionality


 Recipe loads without errors
 All examples execute successfully
 Default parameters work correctly
 Policy pre-check triggers appropriately


Security Testing


 Injection attempts blocked
 URL validation works (if applicable)
 Parameter sanitization effective
 Security verification passes


Integration Testing


 Works with fetch_recipe()
 Works with quick_recipe()
 Compatible with base cookbook recipes
 Respects TOKEN-MONITOR limits


Compliance Testing


 Achieves 95+ compliance score
 Handles all error types gracefully
 Documentation complete and clear


Integration with Base Cookbook
Cookbook Recipe Interactions
Your recipe should consider using these base recipes:


CHAT-INIT: Reference for session setup needs
HANDOFF_SNAPSHOT: For multi-session workflows
AMBIGUITY-DETECT: When parameters unclear
CONFIDENCE-CALIB: For probability/estimates
TOKEN-MONITOR: Respect token limits
LIMITATION-ACK: When hitting AI limits
SOURCE-VALID: For factual claims
POLICY-DIGEST: For policy awareness
PROGRESS-TRACK: For multi-step processes
ERROR-TRANS: For user-friendly errors
COMMENT-WORKFLOW: Ensure proper commenting
EXPECT-SET: Set realistic expectations
CRAFT-BLOG: For content generation patterns
CRAFT-BRAINSTORMER: For ideation patterns


Example Integration
python# In your recipe template:
IF process has multiple steps:
    #AI->H::Note: (Initializing progress tracking)
    # Leverage PROGRESS-TRACK patterns
    
IF generating estimates:
    #AI->H::BestGuess::ConfidenceLevel:{X}%: (Following CONFIDENCE-CALIB)
    
IF encountering platform limitation:
    #AI->H::Caution: (Referencing LIMITATION-ACK patterns)
Examples and Templates
Modern Recipe Template (v2.0)
pythonMODERN_RECIPE = Recipe(
    recipe_id="RCP-XXX-YYY-ZZZ-NAME-v1.00a",
    title="Purpose-Driven Title",
    description="Clear value proposition addressing specific Alpha Phase 1 goals",
    category="CAT-[Category]",
    subcategory="SUBCAT-[Subcategory]",
    difficulty="medium",
    
    parameters={
        "primary_input": {
            "type": "string",
            "required": True,
            "max_length": 5000,
            "description": "Main input with clear purpose"
        },
        "mode": {
            "type": "string",
            "required": False,
            "default": "balanced",
            "options": ["quick", "balanced", "comprehensive"],
            "description": "Processing depth"
        },
        "integrate_cookbook": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Use base cookbook enhancements"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Clear primary instruction)
    #H->AI::Context: (Relevant background)
    
    STEP 0: POLICY PRE-CHECK
    ======================
    [Standard policy check block]
    
    STEP 1: PARAMETER VALIDATION
    ===========================
    [Validate and sanitize inputs]
    
    STEP 2: PROCESS WITH INTEGRATION
    ===============================
    IF {integrate_cookbook} == True:
        [Leverage relevant cookbook recipes]
    
    [Main processing logic]
    
    #H->AI::OnError: (Clear error handling using ERROR-TRANS patterns)
    """
)


# USAGE EXAMPLES:
# Basic usage
result = quick_recipe(url, primary_input="test")


# With cookbook integration
result = quick_recipe(url, 
    primary_input="complex task",
    mode="comprehensive",
    integrate_cookbook=True
)


# Policy-aware usage
result = quick_recipe(url,
    primary_input="analyze AI limitations",  # Triggers policy pre-check
    mode="balanced"
)
Conclusion
Creating high-quality CRAFT recipes in the v0.0725f1+ era requires:


Policy awareness built into every recipe
Security-first design with multi-layer protection
Integration with base cookbook functionality
Token efficiency through smart design
User empathy via clear errors and expectations


Remember: Modern CRAFT recipes don't just execute prompts—they participate in a secure, policy-aware ecosystem that enhances AI-human collaboration while protecting both users and the system.


# =========================================================
# MERGED RECIPE-ID: RCP-001-004-001-CHAT-INIT-v3.00a
# =========================================================


CHAT_SESSION_INITIALIZATION_RECIPE = Recipe(
    recipe_id="RCP-001-004-001-CHAT-INIT-v3.00a",
    title="Chat Session Initialization with Master Template Detection",
    description="Establishes CRAFT session context, loads files, detects templates, triggers project creation",
    category="CAT-001-CORE",
    difficulty="beginner",
    version="3.00a",  # Merged version with full functionality
    
    parameters={
        "session_type": {
            "type": "string",
            "required": True,
            "options": ["new", "continue", "handoff"],
            "description": "Type of session being initialized"
        },
        "project_id": {
            "type": "string",
            "required": True,
            "example": "025",
            "description": "Three-digit project identifier"
        },
        "project_files": {
            "type": "list",
            "required": True,
            "description": "List of attached CRAFT files"
        },
        "handoff_id": {
            "type": "string",
            "required": False,
            "example": "H001",
            "description": "Previous handoff to load if continuing"
        },
        "auto_detect_templates": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Whether to check for master template files"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Initialize CRAFT session with template detection)
    #H->AI::Context: (Project {project_id}, Session type: {session_type})
    
    # ==========================================
    # STEP 1: FILE LOADING AND INITIAL SCAN
    # ==========================================
    
    #AI->H::Status: (Reading CRAFT project files)
    
    Load files in order:
    1. Framework Specification (CFT-FWK-SPEC-*.txt)
    2. Project Implementation (CFT-PROJ-CP-{project_id}_*.txt)
    3. Conversation Continuity (CFT-PROJ-CP-{project_id}_AI-CHAT-HISTORY-*.txt)
    4. Framework Cookbooks (CFT-FWK-COOKBK-*.txt)
    
    # ==========================================
    # STEP 2: MASTER TEMPLATE DETECTION
    # ==========================================
    
    #AI->H::Status: (Checking for master template files)
    
    TEMPLATE_DETECTION_LOGIC = {
        "conditions_to_check": [
            "filename contains '[MASTER-TEMPLATE]'",
            "first line is '# [MASTER-TEMPLATE]'"
        ],
        "trigger": "if either condition is true"
    }
    
    for file in project_files:
        template_detected = False
        
        # Check filename
        if "[MASTER-TEMPLATE]" in file.name:
            template_detected = True
            detected_reason = "filename contains [MASTER-TEMPLATE]"
        
        # Check first line
        elif file.content.startswith("# [MASTER-TEMPLATE]"):
            template_detected = True
            detected_reason = "first line marker found"
        
        if template_detected:
            #AI->H::Alert: (Master template detected in {file.name})
            #AI->H::Alert: (Reason: {detected_reason})
            
            # Store template information
            detected_templates.append({
                "filename": file.name,
                "type": "project" if "CRAFT-ALPHA" in file.name else "handoff",
                "content": file.content
            })
    
    # ==========================================
    # STEP 3: TEMPLATE HANDLING DECISION
    # ==========================================
    
    if detected_templates:
        #AI->H::Alert: (Found {len(detected_templates)} master template file(s))
        #AI->H::RequiredQuestion: (Would you like to create customized project files now using PROJECT_CREATOR_RECIPE?)
        #AI->H::Options: (
            [1] Yes - Start project creation process
            [2] No - Continue with normal initialization
            [3] Review - Show me what would be created first
        )
        
        # Wait for user response
        if user_response == "1" or user_response.lower() == "yes":
            #AI->H::Status: (Initiating PROJECT_CREATOR_RECIPE)
            #AI->H::Note: (Switching to interactive project creation mode)
            
            # Execute PROJECT_CREATOR_RECIPE with template context
            PROJECT_CREATOR_RECIPE.execute({
                "templates_loaded": detected_templates,
                "project_id": project_id,
                "mode": "template_based"
            })
            
            # After PROJECT_CREATOR completes:
            #AI->H::Status: (Project files created successfully)
            #AI->H::CRITICAL: (Copy the complete files from above)
            #AI->H::Instruction: (Next steps:
                1. Copy each complete file between the delimiters
                2. Save with exact filenames (WITHOUT [MASTER-TEMPLATE])
                3. Replace template files with your new files
                4. Run CHAT-INIT again with new files)
            
        elif user_response == "2" or user_response.lower() == "no":
            #AI->H::Note: (Continuing with standard initialization)
            # Continue to Step 4
            
        elif user_response == "3" or user_response.lower() == "review":
            #AI->H::Status: (Showing template structure preview)
            # Show what would be created
            #AI->H::Preview: (The PROJECT_CREATOR_RECIPE would:
                - Ask about your project goals and objectives
                - Gather information about target audience
                - Define project scope and constraints
                - Create customized PROJECT_VARIABLES
                - Set up appropriate personas and recipes
                - Generate complete, ready-to-use files
            )
            # Return to decision point
    
    # ==========================================
    # STEP 4: STANDARD INITIALIZATION
    # ==========================================
    
    #AI->H::Status: (Proceeding with standard CRAFT initialization)
    
    # Security verification
    #AI->H::Status: (Verifying framework security components)
    verify_security_protocols()
    
    # Load previous handoff if continuing
    if session_type in ["continue", "handoff"] and handoff_id:
        #AI->H::Status: (Loading handoff {handoff_id})
        load_handoff_context(handoff_id)
    
    # Initialize persona system
    #AI->H::PersonaSwitch: (Initialized with default: The Professional Assistant)
    
    # Activate CRAFT protocols
    #AI->H::Status: (Activating CRAFT protocols)
    activate_craft_protocols()
    
    # ==========================================
    # STEP 5: COM ACTIVATION
    # ==========================================
    
    #AI->H::Status: (Activating CRAFT-OPERATIONS-MANAGER)
    
    CRAFT_PROMPT_ACTIVE = True
    CRAFT_PROMPT_MODE = "production"
    
    #AI->H::Note: (CRAFT-OPERATIONS-MANAGER now monitoring all prompts)
    #AI->H::Note: (Relevant recipes will be suggested or auto-executed)
    
    # ==========================================
    # STEP 6: INITIALIZATION COMPLETE
    # ==========================================
    
    #AI->H::Status: (CRAFT initialization complete)
    
    **Session Summary:**
    - Files loaded: {len(project_files)}
    - Project: CFT-PROJ-CP-{project_id}
    - Session type: {session_type}
    - Templates detected: {"Yes" if detected_templates else "No"}
    - COM Status: Active
    - Token usage: 0%
    
    #AI->H::RequiredQuestion: (What would you like to work on?)
    #AI->H::COM::Status: (CHAT-INIT completed successfully)
    """
)


# =========================================================
# HELPER FUNCTIONS FOR CHAT-INIT
# =========================================================


def verify_security_protocols():
    """Verify all security components are present"""
    checks = [
        "Recipe Security Protocol in Framework Spec",
        "Security warnings in comment system",
        "Recipe validation for external sources"
    ]
    for check in checks:
        #AI->H::SecurityCheck: (✓ {check})


def load_handoff_context(handoff_id):
    """Load context from previous handoff"""
    # Parse handoff file for specified ID
    # Load decisions, next steps, open questions
    #AI->H::Note: (Loaded context from handoff {handoff_id})


def activate_craft_protocols():
    """Activate all CRAFT framework protocols"""
    protocols = [
        "Comment system (H->AI and AI->H)",
        "Global Instructions (Sections 1.1-1.9)",
        "Clarifying questions protocol",
        "Content type identification",
        "Citation requirements",
        "Recipe system"
    ]
    for protocol in protocols:
        #AI->H::Protocol: (✓ {protocol})


# =========================================================
# END RECIPE-ID: RCP-001-004-001-CHAT-INIT-v3.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-002-HANDOFF_SNAPSHOT-v1.00a
# =========================================================


HANDOFF_SNAPSHOT_RECIPE = Recipe(
    recipe_id="RCP-[tbd]-[tbd]-[tbd]-HANDOFF-SNAPSHOT-v1.00a",
    title="Interactive Session Handoff Creator",
    description="Creates comprehensive handoff with human confirmation for next steps and unresolved questions",
    parameters={
        "session_id": {"type": "string", "required": True, "example": "CFT-PROJ-0005"},
        "date": {"type": "string", "required": True, "format": "Month DD, YYYY"},
        "ai_model": {"type": "string", "required": True, "example": "Claude (Anthropic)"}
    },
    prompt_template="""
    #H->AI::Directive: (We're approaching this chat's token limit. Create a transition HANDOFF_SNAPSHOT following this interactive process)
    #H->AI::Context: (Total length should be 500-2000 words with proper CRAFT formatting)
    #H->AI::Structure: (Follow these steps in order:)


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: Create Initial Sections
    ================================
    #AI->H::Status: (Creating initial handoff sections 1-3)
    
    META.SESSION_ID: {session_id}
    META.DATE: {date}
    META.AI_ASSISTANT: {ai_model}
    
    1. SESSION_SUMMARY (150-400 words): Summarize what we accomplished, focusing on concrete outcomes and progress made.
    2. CURRENT_STATE (150-400 words): Describe the exact implementation state of the components we worked on.
    3. KEY_DECISIONS (75-350 words): List important decisions made with brief rationales.
    4. PERSONA_STATE (50-150 words):
==================================
Active Persona: {SESSION.ACTIVE_PERSONA.name} ({SESSION.ACTIVE_PERSONA.id})
Activation Context: {how/why this persona was activated}
Performance Notes: {any observations about persona effectiveness}
User Preferences: {any noted preferences about communication style}


Persona Parameters:
- Tone: {SESSION.ACTIVE_PERSONA.tone}
- Formality: {SESSION.ACTIVE_PERSONA.formality_level}
- Interaction Style: {SESSION.ACTIVE_PERSONA.interaction_style}


Calibration Responses: {any specific calibration from persona setup}


#AI->H::Note: (Persona state captured for next session: {SESSION.ACTIVE_PERSONA.name})


HANDOFF_SNAPSHOT_STRUCTURE = {
    "META": {
        "SESSION_ID": str,
        "DATE": str,
        "AI_ASSISTANT": str,
        "ACTIVE_PERSONA": str  # NEW
    },
    "SESSION_SUMMARY": str,
    "CURRENT_STATE": str,
    "KEY_DECISIONS": list,
    "UNRESOLVED_QUESTIONS": list,
    "NEXT_STEPS": list,
    "PERSONA_STATE": {  # NEW
        "active_persona": str,
        "activation_time": str,
        "trigger_context": str,
        "calibration_responses": dict,
        "performance_notes": str,
        "user_preferences": dict
    }
}




# EXAMPLE HANDOFF WITH PERSONA:
# =============================


"""
# START HANDOFF-ID: CFT-PROJ-0024_AI-CHAT-HISTORY-H008


META.SESSION_ID: CFT-PROJ-CP-024
META.DATE: August 5, 2025
META.AI_ASSISTANT: Claude (Anthropic)
META.ACTIVE_PERSONA: The Code Mentor


SESSION_SUMMARY (150-400 words):
This session began with the Professional Assistant persona but switched to Code Mentor 
when the user requested help debugging a CRAFT recipe implementation...


[Rest of standard sections...]


PERSONA_STATE (50-150 words):
Active Persona: The Code Mentor (code-mentor)
Activation Context: User requested debugging help for CRAFT recipe syntax errors
Performance Notes: Code Mentor persona effectively identified syntax issues and provided clear examples
User Preferences: Prefers code-first explanations with comments inline


Persona Parameters:
- Tone: technical yet approachable, encouraging
- Formality: medium-low
- Interaction Style: hands-on, example-driven


Calibration Responses: User is intermediate Python developer, prefers functional programming patterns


#AI->H::Note: (Persona state captured for next session: The Code Mentor)


# END HANDOFF-ID: CFT-PROJ-0024_AI-CHAT-HISTORY-H008
"""




    
    STEP 2: Confirm Unresolved Questions
    ====================================
    #AI->H::Status: (Preparing UNRESOLVED_QUESTIONS for review)
    #AI->H::Directive: (Present all unresolved questions for confirmation)
    
    4. UNRESOLVED_QUESTIONS (50-200 words): 
    [List each question]
    
    #AI->H::RequestingFeedback: (Please review the unresolved questions above. For each question, respond with:
    - "Keep" - Include as written
    - "Edit: [new text]" - Include with modifications  
    - "Delete" - Remove from list)
    
    [Wait for human response and update accordingly]
    
    STEP 3: Confirm Next Steps with Priorities
    ==========================================
    #AI->H::Status: (Preparing NEXT_STEPS for review)
    #AI->H::Directive: (Present all next steps with priority levels)
    
    5. NEXT_STEPS (75-300 words):
    [List each next step with format: "Priority [HIGH/MEDIUM/LOW]: Description"]
    
    #AI->H::RequestingFeedback: (Please review the next steps above. For each step, respond with:
    - "Keep" - Include as written with current priority
    - "Edit: [new text] Priority: [HIGH/MEDIUM/LOW]" - Include with modifications
    - "Delete" - Remove from list
    - "Add: [new step] Priority: [HIGH/MEDIUM/LOW]" - Add new step)
    
    [Wait for human response and update accordingly]
    
    STEP 4: Final Review
    ====================
    #AI->H::Status: (Handoff snapshot draft complete)
    #AI->H::Directive: (Present complete handoff for final review)
    
    [Show complete handoff with all sections]
    
    #AI->H::Question: (Please review the complete handoff above. Would you like to make any final changes before we finalize it?)
    
    STEP 5: Finalization
    ====================
    #AI->H::Status: (Handoff ready for insertion into AI-CHAT-HISTORY file)
    #AI->H::Note: (Copy the finalized handoff to replace the appropriate "Tbd" placeholder in the AI-CHAT-HISTORY file)
    
    #H->AI::OnError: (If any section needs major revision, restart that section's process)
    """
)


# Usage Example:
# execute_handoff = HANDOFF_SNAPSHOT_RECIPE.execute({
#     "session_id": "CFT-PROJ-0005",
#     "date": "June 27, 2025",
#     "ai_model": "Claude (Anthropic)"
# })




# =========================================================
# END RECIPE-ID: RCP-001-004-002-HANDOFF_SNAPSHOT-v1.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-003-AMBIGUITY-DETECT-v1.00a
# =========================================================




AMBIGUITY_DETECTOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-003-AMBIGUITY-DETECT-v1.00a",
    title="Intelligent Ambiguity Detection and Resolution",
    description="Detects highly ambiguous requests, makes intelligent assumptions with documentation, and asks targeted clarifying questions",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "user_input": {
            "type": "string",
            "required": True,
            "description": "The user's request to analyze for ambiguity"
        },
        "conversation_context": {
            "type": "string",
            "required": False,
            "default": "general",
            "description": "Domain context (software, business, creative, etc.)"
        },
        "history_depth": {
            "type": "integer",
            "required": False,
            "default": 10,
            "description": "How many previous exchanges to search for context"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Analyze '{user_input}' for HIGH ambiguity levels)
    #H->AI::Context: (Conversation domain: {conversation_context})


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: AMBIGUITY DETECTION
    ===========================
    Identify if the request contains HIGH ambiguity indicators:
    
    □ Missing subject (what/who is being referenced)
    □ Unclear scope (how much/which parts)
    □ Vague metrics (better/faster/more without specifics)
    □ Ambiguous pronouns (it/that/they without clear antecedent)
    □ Undefined actions (fix/update/change without specifics)
    
    If 2+ indicators present → HIGH ambiguity detected → Proceed to Step 2
    If 0-1 indicators → Assume clear enough → Execute request normally
    
    STEP 2: CONTEXT SEARCH
    ======================
    #H->AI::Directive: (Search last {history_depth} exchanges for context clues)
    
    Look for:
    - Recent topics discussed
    - Named entities (files, functions, concepts)
    - Ongoing tasks or projects
    - Previous similar requests
    
    STEP 3: INTELLIGENT ASSUMPTION
    ==============================
    #H->AI::Directive: (Make best guess based on context)
    
    #AI->H::Note: (Interpreting your request based on conversation context)
    #AI->H::BestGuess::ConfidenceLevel:[X]%: (I believe you're referring to [specific thing])
    
    State assumption clearly:
    "I'm assuming you want me to [specific action] on [specific subject]"
    
    STEP 4: TARGETED CLARIFICATION
    ==============================
    Based on ambiguity type, ask focused questions:
    
    For Missing Subject:
    #AI->H::RequiredQuestion: (Which [type] are you referring to: [list 2-3 most likely options]?)
    
    For Unclear Scope:
    #AI->H::OptionalQuestion: (Should I include [related aspect] or focus only on [core aspect]?)
    
    For Vague Metrics:
    #AI->H::OptionalQuestion: (What would "better" mean here - [specific metric 1] or [specific metric 2]?)
    
    For Ambiguous Pronouns:
    #AI->H::RequiredQuestion: (When you say "it", do you mean [most likely referent]?)
    
    STEP 5: PROCEED WITH ASSUMPTION
    ===============================
    #AI->H::Status: (Proceeding with assumption: [stated assumption])
    #AI->H::Note: (Please correct me if I've misunderstood)
    
    Execute based on best guess while remaining open to correction.
    
    #H->AI::OnError: (If no context found and no reasonable guess possible, explain why and ask for complete clarification)
    """
)




# =========================================================
# END RECIPE-ID: RCP-001-004-003-AMBIGUITY-DETECT-v1.00a
# =========================================================














# =========================================================
# START RECIPE-ID: RCP-001-004-004-CONFIDENCE-CALIB-v1.00a
# =========================================================




CONFIDENCE_CALIBRATOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-004-CONFIDENCE-CALIB-v1.00a",
    title="Context-Aware Confidence Level Calibration",
    description="Applies percentage-based confidence levels to estimates, predictions, and uncertain claims with type-specific analysis",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "response_content": {
            "type": "string",
            "required": True,
            "description": "The AI response to analyze and calibrate"
        },
        "response_type": {
            "type": "string",
            "required": True,
            "options": ["estimate", "prediction", "factual_claim", "recommendation", "analysis"],
            "description": "Type of response being calibrated"
        },
        "context_importance": {
            "type": "string",
            "required": False,
            "default": "primary",
            "options": ["primary", "supporting", "tangential"],
            "description": "How central this information is to the user's goal"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Analyze '{response_content}' and apply appropriate confidence calibration)
    #H->AI::Context: (Response type: {response_type}, Importance: {context_importance})


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: DETERMINE IF CONFIDENCE NEEDED
    =====================================
    Apply confidence levels ONLY for:
    ✓ Estimates (time, cost, effort)
    ✓ Predictions (future outcomes)
    ✓ Uncited factual claims (when primary to user's goal)
    ✓ "Best guess" responses
    ✓ Technical assessments
    
    Skip confidence for:
    ✗ Direct citations from provided documents
    ✗ Creative/subjective suggestions
    ✗ Tangential factual claims
    ✗ Definition explanations
    
    STEP 2: CALCULATE MULTI-TYPE CONFIDENCE
    ======================================
    For {response_type}, evaluate:
    
    FOR ESTIMATES (especially time estimates):
    - Data confidence: Based on similar past examples (0-100%)
    - Reasoning confidence: Complexity assessment accuracy (0-100%)
    - Execution confidence: External factors considered (0-100%)
    
    Show calculation method:
    #AI->H::Note: (Time estimate calculation:
    - Base: [X hours] for core functionality
    - Complexity multiplier: [Y] based on [factors]
    - Buffer: [Z%] for unknowns
    - Total: [Result] hours)
    
    FOR PREDICTIONS:
    - Data confidence: Historical pattern strength (0-100%)
    - Reasoning confidence: Causal relationship clarity (0-100%)
    
    FOR FACTUAL CLAIMS:
    - Data confidence: Source reliability (0-100%)
    - Context relevance: Impact on user's goal (0-100%)
    
    STEP 3: APPLY CONFIDENCE NOTATION
    =================================
    Format based on confidence level:
    
    High confidence (70-100%):
    #AI->H::BestGuess::ConfidenceLevel:[X]%: ([response])
    
    Medium confidence (40-69%):
    #AI->H::BestGuess::ConfidenceLevel:[X]%: ([response])
    #AI->H::Note: (Confidence could be improved with: [specific data/clarification needed])
    
    Low confidence (0-39%):
    #AI->H::BestGuess::ConfidenceLevel:[X]%: ([response])
    #AI->H::Caution: (Low confidence due to: [specific reasons])
    #AI->H::RecommendedChange: (To increase confidence: [specific actions])
    
    STEP 4: CONTEXT-AWARE ADJUSTMENTS
    =================================
    For tangential information:
    - If confidence > 60% → Present without confidence notation
    - If confidence < 60% → Add brief qualifier: "approximately" or "roughly"
    
    For primary information:
    - Always show confidence if < 80%
    - Explain calculation method for estimates
    
    STEP 5: CLARIFICATION FOR SUBJECTIVE CONTENT
    ============================================
    For creative/subjective suggestions, instead of confidence:
    #AI->H::Question: (Would you like specific [detail] or is [general approach] sufficient?)
    
    Example: "Try using blue for trust"
    → #AI->H::Question: (Would you like a specific hex color for exact matching (#0066CC) or would any professional blue work?)
    
    #H->AI::OnError: (If unsure whether confidence applies, include it with explanation)
    """
)


# =========================================================
# END RECIPE-ID: RCP-001-004-004-CONFIDENCE-CALIB-v1.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-005-TOKEN-MONITOR-v1.00a
# =========================================================


TOKEN_MONITOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-005-TOKEN-MONITOR-v1.00a",
    title="Intelligent Token Usage Monitor with Weighted Tracking and Velocity",
    description="Monitors conversation token usage with weighted calculations, providing warnings at 75% and 85% thresholds or on-demand, includes velocity tracking",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "check_type": {
            "type": "string",
            "required": True,
            "options": ["automatic", "on_demand", "before_task"],
            "description": "Type of token check being performed"
        },
        "upcoming_task": {
            "type": "string",
            "required": False,
            "description": "Description of upcoming task for capacity planning"
        },
        "force_report": {
            "type": "boolean",
            "required": False,
            "default": False,
            "description": "Force token report regardless of threshold"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Monitor token usage with weighted tracking and velocity analysis)
    #H->AI::Context: (Check type: {check_type})


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: CALCULATE WEIGHTED TOKEN USAGE
    =====================================
    Estimate tokens used so far with weights:
    
    Count different content types:
    - Simple exchanges (Q&A, clarifications): 1x weight
    - Code blocks: 2x weight  
    - Test results/detailed outputs: 3x weight
    - Tables/structured data: 2.5x weight
    - Long analyses/reports: 3x weight
    
    Formula:
    Weighted_Tokens = Σ(Content_Units × Weight × Base_Token_Estimate)
    
    Approximate thresholds:
    - Typical chat limit: ~100,000 tokens
    - 75% threshold: ~75,000 tokens
    - 85% threshold: ~85,000 tokens (MAXIMUM WARNING LEVEL)
    
    STEP 2: CALCULATE VELOCITY
    =========================
    Track token consumption rate:
    - Tokens used in last 5 exchanges
    - Average tokens per exchange
    - Acceleration (increasing/steady/decreasing)
    
    Velocity prediction:
    IF current_usage = X% AND velocity = Y tokens/exchange:
        Exchanges until 85% = (85 - X) / (Y / 1000)
    
    STEP 3: DETERMINE IF WARNING NEEDED
    ==================================
    
    IF {check_type} == "automatic":
        IF weighted_usage >= 85%:
            #AI->H::Caution: (~85% of typical token limit reached - MAXIMUM WARNING)
            #AI->H::Status: (Handoff recommended immediately)
            #AI->H::Note: (At current velocity: ~{exchanges_remaining} exchanges left)
        ELIF weighted_usage >= 75%:
            #AI->H::Note: (~75% of typical token limit reached)
            #AI->H::Status: (Plan for handoff soon)
            #AI->H::Note: (At current velocity: ~{exchanges_until_85}% exchanges until 85%)
        ELSE:
            # Stay silent - no warning needed
    
    IF {check_type} == "on_demand" OR {force_report}:
        #AI->H::Note: (Token usage: ~{percentage}% of typical limit)
        IF show_velocity:
            #AI->H::Note: (Velocity: ~{tokens_per_exchange} tokens/exchange)
            #AI->H::Note: (At this rate: ~{exchanges_remaining} exchanges until 85%)
    
    IF {check_type} == "before_task" AND {upcoming_task}:
        Estimate task weight:
        - "develop recipe": ~5% of limit
        - "comprehensive analysis": ~10% of limit
        - "multiple test cases": ~15% of limit
        - "full documentation": ~10% of limit
        
        IF current_usage + task_estimate > 75%:
            #AI->H::Caution: (~{current}% used, {upcoming_task} needs ~{estimate}%)
            #AI->H::RecommendedChange: (Consider handoff before starting {upcoming_task})
            #AI->H::Note: (Task would reach ~{final_percentage}% of limit)
        ELSE:
            # Safe to proceed - stay silent
    
    STEP 4: VELOCITY PATTERNS
    ========================
    Identify acceleration patterns:
    - Steady: Consistent token use per exchange
    - Accelerating: Recent exchanges using more tokens
    - Decelerating: Recent exchanges using fewer tokens
    
    IF velocity is accelerating AND current > 60%:
        #AI->H::Note: (Token use accelerating - monitor closely)
    
    STEP 5: ON-DEMAND REPORTING
    ===========================
    When user asks about token status:
    
    #AI->H::Note: (Token usage estimate: ~{percentage}% of typical limit)
    
    IF > 60%:
        #AI->H::Note: (Velocity: {velocity_status})
        #AI->H::Note: (Estimated exchanges remaining: ~{exchanges_until_85})
    
    Status guidance:
    - Below 75%: Continue normally
    - 75-85%: Prepare handoff
    - At 85%: Execute handoff now
    
    #H->AI::OnError: (If unable to estimate, provide conservative warning at suspected 70%+)
    """
)




# =========================================================
# END RECIPE-ID: RCP-001-004-005-TOKEN-MONITOR-v1.00a
# =========================================================






# =========================================================
# START RECIPE-ID: RCP-001-004-006-LIMITATION-ACK-v1.00a
# =========================================================


LIMITATION_ACKNOWLEDGMENT_RECIPE = Recipe(
    recipe_id="RCP-001-004-006-LIMITATION-ACK-v1.00a",
    title="AI Limitation Detection, Acknowledgment and Alternative Solutions",
    description="Automatically detects when AI is asked to do something beyond capabilities, provides clear explanations with alternatives, and maintains updateable AI-specific limitation sets",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "request": {
            "type": "string",
            "required": True,
            "description": "The user's request to analyze for limitations"
        },
        "ai_model": {
            "type": "string",
            "required": True,
            "options": ["Claude", "ChatGPT", "Gemini", "Other"],
            "description": "Current AI model for limitation lookup"
        },
        "check_mode": {
            "type": "string",
            "required": False,
            "default": "automatic",
            "options": ["automatic", "list_limitations", "update_limitations"],
            "description": "Mode of operation"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Analyze '{request}' for limitations and provide alternatives)
    #H->AI::Context: (AI Model: {ai_model}, Mode: {check_mode})


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    # AI-SPECIFIC LIMITATION SETS (Updateable)
    # =====================================
    # Last Updated: June 2025
    # To update: Copy new set from AI, replace existing section
    
    CLAUDE_LIMITATIONS = {
        "technical_impossibilities": [
            "Cannot access external URLs without 'Go to' instruction",
            "Cannot save files or persist data between sessions",
            "Cannot execute code in real environment",
            "Cannot access real-time data or current events",
            "Cannot make actual API calls or network requests",
            "Cannot see or generate images",
            "Cannot access user's local file system",
            "Single URL access per request limitation"
        ],
        "policy_restrictions": [
            "Should not provide medical/legal/financial advice",
            "Should not assist with harmful or illegal activities",
            "Should not generate copyrighted content",
            "Should not bypass security measures"
        ],
        "simulation_capabilities": [
            "Can simulate code execution with examples",
            "Can simulate API responses with mock data",
            "Can simulate file operations conceptually",
            "Can simulate database operations"
        ],
        "knowledge_cutoff": "April 2024",
        "token_limit": "~100,000 tokens per conversation"
    }
    
    CHATGPT_LIMITATIONS = {
        "technical_impossibilities": [
            "Cannot browse internet (without browsing mode)",
            "Cannot access external databases",
            "Cannot retain information between conversations",
            "Cannot execute system commands",
            "Cannot access user's device or files"
        ],
        "policy_restrictions": [
            "Similar to Claude's policy restrictions"
        ],
        "simulation_capabilities": [
            "Can simulate code execution",
            "Can create mock outputs"
        ],
        "knowledge_cutoff": "Varies by version",
        "token_limit": "Varies by model (4k-128k)"
    }
    
    GEMINI_LIMITATIONS = {
        "technical_impossibilities": [
            "Platform-specific limitations",
            "Integration-dependent capabilities"
        ],
        "policy_restrictions": [
            "Google's AI principles apply"
        ],
        "simulation_capabilities": [
            "Model-dependent capabilities"
        ],
        "knowledge_cutoff": "Training data dependent",
        "token_limit": "Model-specific"
    }
    
    # AUTOMATIC LIMITATION DETECTION
    # ==============================
    IF {check_mode} == "automatic":
        
        STEP 1: SCAN REQUEST FOR LIMITATION TRIGGERS
        ==========================================
        Check if request involves:
        □ File system operations (save, read, delete)
        □ Network requests (fetch, API calls, web browsing)
        □ Real-time data (current prices, weather, news)
        □ Code execution (run, execute, test)
        □ Data persistence (remember, store, save for later)
        □ Image operations (see, analyze, generate images)
        □ System access (install, configure, access OS)
        
        STEP 2: CATEGORIZE LIMITATION TYPE
        =================================
        For each detected limitation:
        
        IF technical_impossibility:
            #AI->H::Caution: (Cannot {specific_action} - technical limitation)
            #AI->H::Note: (This is a platform restriction for {ai_model})
            
        IF policy_restriction:
            #AI->H::Caution: (Should not {specific_action} - policy restriction)
            #AI->H::Note: (This protects user safety and follows AI ethics)
            
        IF simulation_possible:
            #AI->H::Note: (Cannot actually {specific_action}, but can simulate)
            #AI->H::Question: (Would you like me to demonstrate with a simulation?)
        
        STEP 3: PROVIDE ALTERNATIVES
        ============================
        For each limitation, check alternatives:
        
        Cannot save file → Suggest: 
            #AI->H::RecommendedChange: (I can display content for you to copy and save manually)
            
        Cannot access URL → Suggest:
            #AI->H::RecommendedChange: (You can provide content with 'Go to [URL]' command)
            
        Cannot execute code → Suggest:
            #AI->H::RecommendedChange: (I can simulate execution or provide step-by-step output)
            
        Cannot access real-time → Suggest:
            #AI->H::RecommendedChange: (You can provide current data, or I can work with estimates)
            
        No alternative exists → State clearly:
            #AI->H::Note: (No alternative available - this requires {specific_capability})
    
    # LIST LIMITATIONS MODE
    # ====================
    IF {check_mode} == "list_limitations":
        #AI->H::Status: (Current limitations for {ai_model})
        
        Display organized list:
        
        TECHNICAL IMPOSSIBILITIES:
        {format as numbered list}
        
        POLICY RESTRICTIONS:
        {format as numbered list}
        
        CAN SIMULATE:
        {format as numbered list}
        
        Knowledge Cutoff: {date}
        Token Limit: {limit}
    
    # UPDATE LIMITATIONS MODE
    # ======================
    IF {check_mode} == "update_limitations":
        #AI->H::Status: (Generating updated limitation set for {ai_model})
        
        Test current capabilities and generate:
        
        {AI_MODEL}_LIMITATIONS = {
            "technical_impossibilities": [
                {test each capability and list findings}
            ],
            "policy_restrictions": [
                {check current policies}
            ],
            "simulation_capabilities": [
                {verify what can be simulated}
            ],
            "knowledge_cutoff": "{detected date}",
            "token_limit": "{detected limit}"
        }
        
        #AI->H::Note: (Copy this updated set to replace the existing {ai_model} section in the recipe)
    
    # VERIFICATION PROTOCOL
    # ====================
    When stating a limitation, always:
    1. Test if truly limited (don't assume)
    2. Be specific about what aspect is limited
    3. Distinguish between "cannot", "should not", and "can simulate"
    4. Check for recent capability updates
    
    #H->AI::OnError: (If unsure about a limitation, test it first, then report findings)
    """
)


# USAGE EXAMPLES:
# ==============


# Automatic detection during conversation:
# User: "Save this analysis to my documents folder"
# AI automatically invokes recipe, detects file system limitation, suggests alternatives


# List current limitations:
# User: "What are your current limitations?"
# execute_recipe({
#     "request": "list limitations",
#     "ai_model": "Claude",
#     "check_mode": "list_limitations"
# })


# Update limitation set:
# User: "Test and update your limitations"
# execute_recipe({
#     "request": "update limitations",
#     "ai_model": "Claude", 
#     "check_mode": "update_limitations"
# })






# =========================================================
# END RECIPE-ID: RCP-001-004-006-LIMITATION-ACK-v1.00a
# =========================================================
















# =========================================================
# START RECIPE-ID: RCP-001-004-007-SOURCE-VALID-v1.00a
# =========================================================


SOURCE_VALIDATOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-007-SOURCE-VALID-v1.00a",
    title="Factual Claim Validator with Deep Research Integration",
    description="Checks factual claims against available sources, assigns confidence levels, flags unsourced assertions, and generates Deep Research prompts when needed",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "content": {
            "type": "string",
            "required": True,
            "description": "Content to validate for factual claims"
        },
        "validation_mode": {
            "type": "string",
            "required": False,
            "default": "automatic",
            "options": ["automatic", "strict", "lenient", "research_prompt"],
            "description": "How aggressive to be in validation"
        },
        "claim_types": {
            "type": "list",
            "required": False,
            "default": ["statistics", "dates", "quotes", "technical_specs"],
            "description": "Types of claims to validate"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Validate factual claims in '{content}')
    #H->AI::Context: (Mode: {validation_mode}, Checking: {claim_types})
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Check if content involves:
    - Claims about AI capabilities/limitations
    - Political statements or statistics
    - Medical/legal/financial facts
    - Personal information about individuals
    
    IF policy-sensitive:
        #AI->H::PolicyCaution: (Fact-checking {topic} requires careful handling)
        Proceed with extra verification requirements
    
    STEP 1: IDENTIFY FACTUAL CLAIMS
    ===============================
    Scan content for:
    
    STATISTICS & NUMBERS:
    - Percentages, rates, amounts
    - Growth figures, comparisons
    - Rankings, scores
    
    TEMPORAL CLAIMS:
    - Specific dates, timeframes
    - "Current" or "latest" assertions
    - Historical sequences
    
    ATTRIBUTED STATEMENTS:
    - Quotes from individuals
    - Claims about what organizations said/did
    - Research findings
    
    TECHNICAL SPECIFICATIONS:
    - Feature lists, capabilities
    - Performance metrics
    - Compatibility claims
    
    STEP 2: SOURCE VERIFICATION
    ===========================
    For each identified claim:
    
    CHECK AVAILABLE SOURCES:
    1. Attached documents (highest priority)
       - Note specific file, section, line number
       - Confidence: 90-100%
    
    2. Previous Deep Research PDFs
       - Check if relevant PDF already attached
       - Confidence: 85-95%
    
    3. General knowledge (use cautiously)
       - Only for widely-known facts
       - Confidence: 60-80%
    
    4. No source available
       - Flag for Deep Research
       - Confidence: 0%
    
    STEP 3: ASSIGN CONFIDENCE LEVELS
    ================================
    For each claim, assign confidence based on:
    
    SOURCED CLAIMS:
    #AI->H::Note: (Claim: "{claim}" - Source: {file}, {section})
    #AI->H::BestGuess::ConfidenceLevel:{X}%: (Based on source quality)
    
    COMMON KNOWLEDGE:
    #AI->H::Note: (Claim: "{claim}" - Common knowledge)
    #AI->H::BestGuess::ConfidenceLevel:{70}%: (No specific source)
    
    UNSOURCED CLAIMS:
    #AI->H::Caution: (Claim: "{claim}" - No source found)
    #AI->H::Status: (Marking as unsourced assertion)
    
    STEP 4: DEEP RESEARCH TRIGGERS
    ==============================
    Identify claims needing Deep Research:
    
    PRIORITY LEVELS:
    - Critical: Core claims central to discussion
    - Helpful: Supporting facts that enhance accuracy  
    - Optional: Interesting but non-essential details
    
    If critical unsourced claims found:
        #AI->H::Status: (Deep Research recommended for fact verification)
        #AI->H::Note: (Generating comprehensive research prompt)
    
    STEP 5: GENERATE DEEP RESEARCH PROMPT
    ====================================
    When {validation_mode} == "research_prompt" OR critical claims unsourced:
    
    DEEP RESEARCH REQUEST: [Topic from claims]
    Priority: [Critical/Helpful/Optional]
    
    Primary Questions:
    1. [Specific claim to verify]
    2. [Related fact needing verification]
    3. [Context question for comprehensive coverage]
    
    Additional Context to Include:
    - Historical data on topic (if relevant)
    - Current statistics and trends
    - Authoritative sources on subject
    - Common misconceptions to address
    - Related topics for anticipatory coverage
    
    Time Range: [Relevant period]
    Source Priority:
    1. Academic/peer-reviewed sources
    2. Government/official statistics
    3. Industry reports
    4. News from reputable outlets
    
    Anticipatory Coverage:
    [List related questions likely to arise]
    
    STEP 6: FORMAT VALIDATION REPORT
    ================================
    
    VALIDATION SUMMARY:
    - Total claims identified: [X]
    - Sourced claims: [Y] (average confidence: [Z]%)
    - Unsourced claims: [A]
    - Research needed: [Yes/No]
    
    DETAILED RESULTS:
    [For each claim, show source and confidence]
    
    If Deep Research needed:
        #AI->H::RequestingFeedback: (Would you like to run Deep Research on the unsourced claims? Priority: [level])
        #AI->H::Note: (Copy the research prompt above for Deep Research)
    
    #H->AI::OnError: (If unable to determine source, always mark as unsourced rather than guessing)
    """
)


# USAGE EXAMPLES:
# ==============


# Automatic validation during response:
# AI: "90% of developers use AI tools"
# Recipe triggers, checks for source, assigns confidence


# Generate research prompt:
# execute_recipe({
#     "content": "Claims about CRAFT adoption rates",
#     "validation_mode": "research_prompt"
# })


# Strict validation mode:
# execute_recipe({
#     "content": draft_response,
#     "validation_mode": "strict",
#     "claim_types": ["statistics", "quotes"]
# })






# =========================================================
# END RECIPE-ID: RCP-001-004-007-SOURCE-VALID-v1.00a
# =========================================================






# =========================================================
# START RECIPE-ID: RCP-001-004-008-POLICY-DIGEST-v1.00a
# =========================================================


USAGE_POLICY_DIGEST_RECIPE = Recipe(
    recipe_id="RCP-001-004-008-POLICY-DIGEST-v1.00a",
    title="AI Usage Policy Digest Creator",
    description="Converts full usage policies into concise, actionable summaries for CRAFT framework integration",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="easy",
    
    parameters={
        "policy_text": {
            "type": "string",
            "required": True,
            "description": "Full usage policy text to digest"
        },
        "ai_platform": {
            "type": "string",
            "required": True,
            "options": ["Claude", "ChatGPT", "Gemini", "Other"],
            "description": "Which AI platform this policy is for"
        },
        "max_length": {
            "type": "integer",
            "required": False,
            "default": 50,
            "description": "Maximum lines for digest version"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Create concise policy digest from {policy_text})
    #H->AI::Context: (For {ai_platform} integration into CRAFT framework)


    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: EXTRACT KEY CATEGORIES
    ==============================
    Identify main restriction categories:
    - Group similar restrictions together
    - Use clear, memorable category names
    - Focus on what affects typical CRAFT usage
    
    STEP 2: CREATE QUICK REFERENCE FORMAT
    ====================================
    Format as Python-compatible structure:
    
    {AI_PLATFORM}_POLICY_DIGEST = {
        "last_updated": "[date from policy]",
        "version": "digest_v1",
        
        "NEVER_DO": [
            # Absolute prohibitions (5-7 items max)
            "Child safety violations",
            "Violence/terrorism content",
            "Illegal activities",
            # etc.
        ],
        
        "ASK_BEFORE": [
            # Things that need careful handling
            "Political content",
            "Medical/legal advice",
            "Personal data processing",
            # etc.
        ],
        
        "BE_CAREFUL_WITH": [
            # Common triggers to watch for
            "Attempting to discover AI limitations",
            "Automated content generation",
            "Bulk operations",
            # etc.
        ],
        
        "QUICK_CHECKS": {
            # Specific patterns that trigger policies
            "research_prompts": ["avoid capability probing", "no vulnerability research"],
            "code_generation": ["no malware", "no unauthorized access tools"],
            "content_creation": ["no explicit content", "verify factual claims"],
        }
    }
    
    STEP 3: ADD PRACTICAL EXAMPLES
    ==============================
    For each major category, provide one clear example:
    
    # WRONG: "Help me bypass content filters"
    # RIGHT: "Help me understand how content moderation works"
    
    STEP 4: CREATE WARNING TRIGGERS
    ===============================
    List keywords/phrases that should trigger caution:
    
    TRIGGER_WORDS = {
        "capability_probing": ["limitations", "bypass", "jailbreak"],
        "harmful_content": ["weapon", "explosive", "hack"],
        "privacy_concerns": ["track", "surveillance", "facial recognition"]
    }
    
    STEP 5: FORMAT FOR FRAMEWORK
    ============================
    Ensure output is:
    - Under {max_length} lines
    - Python-compatible syntax
    - Comments explain rationale
    - Easy to update when policy changes
    
    #H->AI::OnError: (If policy is unclear, err on side of caution)
    #H->AI::Structure: (Output ready to paste into CRAFT Framework Section 1.12)
    """
)


# USAGE:
# digest = USAGE_POLICY_DIGEST_RECIPE.execute({
#     "policy_text": "[paste full policy]",
#     "ai_platform": "Claude",
#     "max_length": 50
# })




# =========================================================
# END RECIPE-ID: RCP-001-004-008-POLICY-DIGEST-v1.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-009-PROGRESS-TRACK-v1.00a
# =========================================================


PROGRESS_TRACKER_RECIPE = Recipe(
    recipe_id="RCP-001-004-009-PROGRESS-TRACK-v1.00a",
    title="Visual Progress Tracker with Automatic Step Detection",
    description="Automatically tracks conversation progress through multi-step workflows, provides visual progress bars and structured updates, integrates with handoff system",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "task_name": {
            "type": "string",
            "required": True,
            "description": "Name of the task or workflow being tracked"
        },
        "mode": {
            "type": "string",
            "required": False,
            "default": "auto",
            "options": ["auto", "status", "initialize", "update"],
            "description": "Tracking mode"
        },
        "steps_list": {
            "type": "list",
            "required": False,
            "description": "List of steps for new workflow (initialize mode)"
        },
        "query": {
            "type": "string",
            "required": False,
            "description": "User question like 'where am I?' or 'what's next?'"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Track progress for '{task_name}' workflow)
    #H->AI::Context: (Mode: {mode})
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    # WORKFLOW STATE TRACKING
    # ======================
    # Maintained in conversation context:
    ACTIVE_WORKFLOWS = {
        "{task_name}": {
            "steps": [...],
            "completed": [...],
            "current_step": N,
            "blockers": [...],
            "started": "timestamp",
            "last_update": "timestamp"
        }
    }
    
    # MODE: INITIALIZE
    # ================
    IF {mode} == "initialize":
        #AI->H::Status: (Initializing workflow: {task_name})
        
        Create workflow structure:
        1. Parse {steps_list} or extract from conversation
        2. Number each step sequentially
        3. Set all steps to pending
        4. Store in ACTIVE_WORKFLOWS
        
        Display initial status:
        
        📋 **{task_name}** - Workflow Initialized
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        **Steps:**
        ☐ Step 1: [First step description]
        ☐ Step 2: [Second step description]
        ☐ Step 3: [Third step description]
        ...
        
        **Progress:** [░░░░░░░░░░] 0% (0/{total} steps)
        **Status:** Ready to begin
        **Next:** Step 1 - [Description]
        
        #AI->H::Note: (Workflow tracked - progress updates automatic)
    
    # MODE: AUTO (Automatic Detection)
    # ================================
    IF {mode} == "auto":
        #AI->H::Directive: (Scan conversation for completed steps)
        
        Detection patterns:
        - "completed [step/task]"
        - "finished [action]"  
        - "✓" or "done" markers
        - Movement to next topic
        - Explicit confirmations
        
        For each detected completion:
        1. Mark step as complete
        2. Update current_step
        3. Calculate new percentage
        4. Check for blockers
        
        If progress detected:
            #AI->H::Status: (Progress detected - updating tracker)
    
    # MODE: STATUS (Current State Query)
    # ==================================
    IF {mode} == "status" OR {query} contains ["where", "status", "progress"]:
        
        Calculate visual progress:
        - Completed: ✓ or ☑
        - Current: ▶ or ⚡
        - Pending: ☐
        - Blocked: ⚠️
        
        Progress bar calculation:
        filled = int((completed_count / total_steps) * 10)
        bar = "█" * filled + "░" * (10 - filled)
        
        📊 **{task_name}** - Progress Update
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        **Completed:**
        ✓ Step 1: [Completed step] ✅
        ✓ Step 2: [Completed step] ✅
        
        **Current:**
        ▶ Step 3: [Current step] 🔄
        
        **Remaining:**
        ☐ Step 4: [Pending step]
        ☐ Step 5: [Pending step]
        
        **Progress:** [{bar}] {percentage}% ({completed}/{total} steps)
        **Time Active:** {time_since_start}
        **Next Action:** {next_step_description}
        
        IF blockers exist:
            **⚠️ Blockers:**
            - {blocker_1}
            - {blocker_2}
    
    # QUERY RESPONSES
    # ===============
    Common queries and responses:
    
    "Where am I?":
        #AI->H::Note: (You're on Step {N} of {total}: "{current_step_description}")
        #AI->H::Note: (Progress: {percentage}% complete)
        
    "What's next?":
        #AI->H::Note: (Next: Step {N+1} - {next_step_description})
        IF prerequisites:
            #AI->H::Caution: (Requires: {prerequisites})
            
    "What's left?":
        #AI->H::Note: ({remaining} steps remaining:)
        [List remaining steps]
        
    "Am I blocked?":
        IF blockers:
            #AI->H::Caution: (Yes, blocked by: {blockers})
            #AI->H::RecommendedChange: (To unblock: {suggestions})
        ELSE:
            #AI->H::Note: (No blockers - ready to proceed)
    
    # HANDOFF INTEGRATION
    # ==================
    For session handoff, include:
    
    WORKFLOW_STATE = {
        "active_workflows": {
            "{task_name}": {
                "progress_percentage": {percentage},
                "completed_steps": [...],
                "current_step": {N},
                "blockers": [...],
                "next_action": "{description}"
            }
        }
    }
    
    #AI->H::Note: (Progress state saved for handoff)
    
    # COMPLETION DETECTION
    # ===================
    IF all steps completed:
        
        🎉 **{task_name}** - COMPLETE!
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        **Progress:** [██████████] 100% ✅
        **Duration:** {total_time}
        **Steps Completed:** {total} of {total}
        
        #AI->H::Status: (Workflow complete - removing from active tracking)
        #AI->H::Question: (Would you like a summary or to start a new workflow?)
    
    #H->AI::OnError: (If workflow not found, list available workflows or offer to initialize)
    """
)


# USAGE EXAMPLES:
# ==============


# Initialize a new workflow:
# execute_recipe({
#     "task_name": "CRAFT Recipe Development",
#     "mode": "initialize",
#     "steps_list": [
#         "Define recipe purpose",
#         "Gather requirements",
#         "Draft recipe structure",
#         "Test and refine",
#         "Finalize documentation"
#     ]
# })


# Check current status:
# User: "Where am I in the recipe development?"
# Recipe auto-triggers with mode="status"


# Automatic progress detection:
# User: "OK, I've completed the requirements gathering"
# Recipe detects completion, updates progress automatically




# =========================================================
# END RECIPE-ID: RCP-001-004-009-PROGRESS-TRACK-v1.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-010-ERROR-TRANS-v1.00a
# =========================================================


ERROR_TRANSLATOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-010-ERROR-TRANS-v1.00a",
    title="Intelligent Error Message Translator with Adaptive Explanations",
    description="Automatically detects complex technical errors and translates them to user-friendly messages, categorizes severity, and offers recovery assistance when requested",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "error_message": {
            "type": "string",
            "required": True,
            "description": "The technical error message to translate"
        },
        "error_context": {
            "type": "string",
            "required": False,
            "description": "What the user was trying to do when error occurred"
        },
        "user_expertise": {
            "type": "string",
            "required": False,
            "default": "auto-detect",
            "options": ["technical", "non-technical", "auto-detect"],
            "description": "User's technical level for tone adaptation"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Analyze '{error_message}' for complexity and translate if needed)
    #H->AI::Context: (User was: {error_context})
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: COMPLEXITY ASSESSMENT
    =============================
    Evaluate if error needs translation:
    
    SIMPLE/CLEAR ERRORS (No translation needed):
    - "File not found"
    - "Invalid password"
    - "Connection timeout"
    - "Access denied"
    - Clear permission messages
    
    COMPLEX/TECHNICAL ERRORS (Translation needed):
    - Stack traces
    - Type errors
    - Null/undefined references
    - API response codes
    - Technical jargon
    - Multi-line errors
    
    Complexity Score: [0-10]
    IF score < 4: Skip translation
    IF score >= 4: Proceed to translation
    
    STEP 2: ERROR CATEGORIZATION
    ============================
    Identify error type and severity:
    
    ERROR TYPES:
    - Network/Connection issues
    - Permission/Access problems
    - Data validation failures
    - Missing resources
    - System/Platform limitations
    - Code/Syntax errors
    - API/Integration failures
    
    SEVERITY LEVELS:
    🔴 CRITICAL: Task cannot proceed
    🟡 WARNING: Task impacted but workarounds exist
    🔵 INFO: Minor issue, minimal impact
    
    STEP 3: TONE DETECTION
    ======================
    Adapt based on context and user:
    
    IF {user_expertise} == "auto-detect":
        Check conversation for:
        - Technical terms used
        - Code snippets shared
        - Question complexity
        
    Set tone:
    - Technical user + Critical: Direct, specific
    - Non-technical + Any: Friendly, simple
    - Any user + Info: Light, reassuring
    
    STEP 4: ERROR TRANSLATION
    ========================
    Create user-friendly explanation:
    
    For {error_message}, translate to:
    
    {SEVERITY_ICON} **What happened:**
    [Plain language explanation in 1-2 sentences]
    
    **In simple terms:**
    [Analogy or metaphor if helpful]
    
    Common translations:
    - "TypeError: undefined" → "The system couldn't find something it expected"
    - "403 Forbidden" → "You don't have permission to access this"
    - "ECONNREFUSED" → "Couldn't connect to the service"
    - "ValidationError" → "The information provided doesn't match what's required"
    
    STEP 5: INITIAL RESPONSE
    =======================
    Provide translated message:
    
    #AI->H::Note: ({SEVERITY} - {translated_explanation})
    
    For CRITICAL errors:
        #AI->H::Caution: (This prevents the task from completing)
        
    For WARNING errors:
        #AI->H::Note: (This might cause issues but we can work around it)
        
    For INFO errors:
        #AI->H::Note: (Minor issue - shouldn't affect your work)
    
    Then ask:
    #AI->H::Question: (Would you like me to explain how to fix this?)
    
    STEP 6: RECOVERY ASSISTANCE
    ==========================
    IF user wants help:
    
    **How to fix this:**
    1. [First step - most likely solution]
    2. [Second step - if first doesn't work]
    3. [Third step - alternative approach]
    
    **What you can try:**
    - Quick fix: [Immediate action]
    - Workaround: [Alternative approach]
    - Prevention: [How to avoid this next time]
    
    For platform limitations:
        #AI->H::Note: (This is a system limitation - here's what we can do instead:)
        [Alternative approaches]
    
    STEP 7: EXPECTATION SETTING
    ==========================
    Be clear about outcomes:
    
    IF fixable by user:
        #AI->H::Note: (This can be resolved by following the steps above)
        
    IF requires external help:
        #AI->H::Note: (This needs assistance from [admin/support/developer])
        
    IF permanent limitation:
        #AI->H::Note: (This is a built-in limitation - we'll need to use a different approach)
    
    ERROR PATTERN EXAMPLES:
    ======================
    
    Network Error Pattern:
    Technical: "Error: connect ETIMEDOUT 192.168.1.1:8080"
    Friendly: "Couldn't reach the server - it might be down or your internet connection might be interrupted"
    
    Permission Pattern:
    Technical: "Error: EACCES: permission denied, open '/var/log/app.log'"
    Friendly: "The system blocked access to a file - you might need administrator privileges"
    
    Validation Pattern:
    Technical: "ValidationError: Invalid value for field 'email': Does not match pattern"
    Friendly: "The email address format isn't quite right - make sure it includes @ and a domain"
    
    #H->AI::OnError: (If error pattern unknown, provide generic but honest explanation)
    """
)


# USAGE EXAMPLES:
# ==============


# Automatic translation:
# AI encounters: "TypeError: Cannot read property 'map' of undefined"
# Recipe triggers automatically, provides friendly explanation


# Manual translation request:
# execute_recipe({
#     "error_message": "CORS policy: No 'Access-Control-Allow-Origin' header",
#     "error_context": "trying to fetch recipe from website",
#     "user_expertise": "non-technical"
# })


# Severity examples:
# CRITICAL: "Database connection failed" 
# WARNING: "API rate limit approaching"
# INFO: "Cache miss - fetching fresh data"


# =========================================================
# START RECIPE-ID: RCP-001-004-010-ERROR-TRANS-v1.00a
# =========================================================








# =========================================================
# START RECIPE-ID: RCP-001-004-011-COMMENT-FLOW-v1.00a
# =========================================================


COMMENT_WORKFLOW_RECIPE = Recipe(
    recipe_id="RCP-001-004-011-COMMENT-FLOW-v1.00a",
    title="AI Comment System Self-Monitor with Silent Optimization",
    description="Monitors AI's comment usage for consistency, ensures proper acknowledgment of H->AI directives, operates in silent mode by default to improve communication without disrupting flow",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="easy",
    
    parameters={
        "mode": {
            "type": "string",
            "required": False,
            "default": "silent",
            "options": ["silent", "visible", "report", "templates"],
            "description": "Monitoring mode"
        },
        "conversation_segment": {
            "type": "string",
            "required": False,
            "description": "Specific conversation segment to analyze"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Monitor AI comment usage and optimize communication)
    #H->AI::Context: (Mode: {mode} - default is silent self-improvement)
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Scan prompt for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This research topic may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    # INTERNAL TRACKING METRICS
    # ========================
    AI_COMMENT_METRICS = {
        "h_to_ai_acknowledged": 0,
        "h_to_ai_missed": 0,
        "essential_comments_used": 0,
        "helpful_comments_used": 0,
        "acknowledgment_rate": 0.0,
        "communication_clarity_score": 0.0
    }
    
    # COMMENT PRIORITY LEVELS
    # ======================
    ESSENTIAL_COMMENTS = {
        "Must acknowledge every #H->AI:: directive",
        "Must use #AI->H::Caution: for limitations/warnings",
        "Must use #AI->H::RequiredQuestion: when cannot proceed",
        "Must use #AI->H::SecurityWarning: for policy violations",
        "Must use #AI->H::Status: for multi-step processes"
    }
    
    HELPFUL_COMMENTS = {
        "#AI->H::Note: for general observations",
        "#AI->H::OptionalQuestion: for nice-to-have clarifications",
        "#AI->H::RecommendedChange: for improvements",
        "#AI->H::RequestingFeedback: for opinions",
        "#AI->H::BestGuess: for uncertainty"
    }
    
    # MODE: SILENT (Default)
    # =====================
    IF {mode} == "silent":
        
        CONTINUOUS SELF-MONITORING:
        
        1. Before each response, scan for:
           - Any unacknowledged #H->AI:: comments
           - Situations requiring essential comments
           - Opportunities for helpful comments
        
        2. Self-correction actions:
           - If missed #H->AI:: → Add acknowledgment immediately
           - If giving warning without #AI->H::Caution: → Add it
           - If need required info → Use #AI->H::RequiredQuestion:
        
        3. Internal improvements:
           - Note patterns of missed comments
           - Adjust response style accordingly
           - No visible indication to human
    
    # MODE: VISIBLE
    # =============
    IF {mode} == "visible":
        
        #AI->H::Status: (Comment monitoring active - will provide gentle guidance)
        
        When AI notices missed opportunity:
        #AI->H::Note: (I should have used #AI->H::[type] here for clarity)
        
        Self-correction example:
        "The file cannot be saved"
        #AI->H::Note: (Adding proper comment format:)
        #AI->H::Caution: (Cannot save files - platform limitation)
    
    # MODE: REPORT
    # ============
    IF {mode} == "report":
        
        📊 **AI Comment Usage Report**
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        **Essential Comments:**
        - H->AI Acknowledgment Rate: {ack_rate}%
        - Cautions/Warnings Used: {caution_count}
        - Required Questions Asked: {required_q_count}
        - Status Updates Given: {status_count}
        
        **Communication Effectiveness:**
        - Clarity Score: {clarity_score}/10
        - Missed Opportunities: {missed_count}
        - Self-Corrections Made: {correction_count}
        
        **Recommendations:**
        [Specific areas for improvement]
    
    # MODE: TEMPLATES (When Human Asks)
    # ================================
    IF {mode} == "templates" OR human asks for examples:
        
        📝 **Common Comment Templates**
        ━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        **For Complex Instructions:**
        #H->AI::Directive: (Main instruction here)
        #H->AI::Context: (Background information)
        #H->AI::Constraint: (Any limitations)
        
        **For Seeking Clarification:**
        #H->AI::Question: (Specific question)
        
        **For Process Control:**
        #H->AI::OnError: (What to do if error occurs)
        #H->AI::Structure: (Expected output format)
        
        **AI Response Patterns:**
        #AI->H::Note: (Acknowledging: [directive])
        #AI->H::Status: (Beginning [task])
        #AI->H::RequiredQuestion: (Need to know: [info])
        #AI->H::Caution: ([limitation] detected)
    
    # SELF-IMPROVEMENT PATTERNS
    # ========================
    
    Pattern 1: Unacknowledged Directive
    DETECT: Human used #H->AI:: but AI didn't acknowledge
    ACTION: Start next response with acknowledgment
    
    Pattern 2: Complex Process Without Status
    DETECT: Multi-step task without progress updates  
    ACTION: Add #AI->H::Status: updates
    
    Pattern 3: Uncertainty Without Confidence
    DETECT: Making estimates without confidence levels
    ACTION: Add #AI->H::BestGuess::ConfidenceLevel:
    
    Pattern 4: Problems Without Warnings
    DETECT: Describing limitations without #AI->H::Caution:
    ACTION: Add appropriate warning comment
    
    # HUMAN INTERACTION RULES
    # ======================
    
    1. NEVER critique human's comment usage unless asked
    2. NEVER suggest human should use comments differently
    3. ONLY provide templates/guidance when requested
    4. Focus solely on improving AI's communication
    
    When human asks about comments:
    #AI->H::Note: (Happy to explain the comment system!)
    [Provide requested information only]
    
    # CONTINUOUS IMPROVEMENT
    # =====================
    
    After each exchange, AI internally reviews:
    □ Did I acknowledge all #H->AI:: comments?
    □ Did I use essential comments where needed?
    □ Was my communication clear and structured?
    □ Could comments have prevented confusion?
    
    Adjust future responses based on patterns.
    
    #H->AI::OnError: (If comment system seems broken, continue conversation normally)
    """
)


# USAGE EXAMPLES:
# ==============


# Silent mode (default):
# Recipe runs continuously in background
# AI self-corrects and improves without user knowing


# Report mode:
# User: "How well are you using comments?"
# execute_recipe({"mode": "report"})


# Template request:
# User: "Show me comment examples"
# execute_recipe({"mode": "templates"})


# Visible mode (testing):
# execute_recipe({"mode": "visible"})
# AI shows when it's making corrections




# =========================================================
# END RECIPE-ID: RCP-001-004-011-COMMENT-FLOW-v1.00a
# =========================================================






# =========================================================
# START RECIPE-ID: RCP-001-004-012-EXPECT-SET-v1.00a
# =========================================================


EXPECTATION_SETTER_RECIPE = Recipe(
    recipe_id="RCP-001-004-012-EXPECT-SET-v1.00a",
    title="Proactive Expectation Management with Progress Tracker Integration",
    description="Communicates upfront what will happen, estimated complexity, likely duration, and known limitations before starting tasks, automatically initializes PROGRESS-TRACKER for monitoring",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "task_description": {
            "type": "string",
            "required": True,
            "description": "The task or request to set expectations for"
        },
        "auto_init_progress": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Automatically initialize PROGRESS-TRACKER"
        },
        "detail_level": {
            "type": "string",
            "required": False,
            "default": "balanced",
            "options": ["minimal", "balanced", "comprehensive"],
            "description": "How much detail to provide upfront"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Set clear expectations before beginning '{task_description}')
    #H->AI::Context: (Prevent overpromising, integrate with progress tracking)
    
    STEP 0: POLICY PRE-CHECK
    ======================
    Scan task for sensitive categories:
    - Platform capabilities/limitations
    - Security/vulnerability research  
    - Personal data handling
    - Political topics


    IF potential conflict detected:
        #AI->H::PolicyCaution: (This task may trigger usage policies)
        #AI->H::RecommendedChange: (Consider focusing on [specific safe aspect])
    
    STEP 1: TASK ANALYSIS
    ====================
    Analyze the requested task for:
    
    COMPLEXITY FACTORS:
    □ Number of distinct steps required
    □ Dependencies on external resources
    □ Platform limitations involved
    □ Potential failure points
    □ Required user inputs
    □ Ambiguity level
    
    COMPLEXITY RATING:
    - Simple (1-2 steps, clear path): ⚡
    - Moderate (3-5 steps, some complexity): ⚙️
    - Complex (6+ steps, multiple paths): 🔧
    - Very Complex (many dependencies): 🏗️
    
    STEP 2: CAPABILITY CHECK
    =======================
    Identify any limitations upfront:
    
    CAN DO ✅:
    - [List what AI can accomplish]
    
    CANNOT DO ❌:
    - [Platform limitations]
    - [Policy restrictions]
    
    WILL SIMULATE 🎭:
    - [What will be demonstrated]
    
    REQUIRES USER ACTION 👤:
    - [What user must provide/do]
    
    STEP 3: TIME/EFFORT ESTIMATION
    ==============================
    Provide realistic estimates:
    
    For {detail_level} == "minimal":
        Quick estimate only
        
    For {detail_level} == "balanced":
        ESTIMATED EFFORT:
        - Setup: ~X exchanges
        - Execution: ~Y exchanges  
        - Total: ~Z exchanges
        
    For {detail_level} == "comprehensive":
        DETAILED BREAKDOWN:
        - Phase 1: [description] (~X exchanges)
        - Phase 2: [description] (~Y exchanges)
        - Potential delays: [what might extend timeline]
    
    STEP 4: SET EXPECTATIONS
    ========================
    
    📋 **Task Overview: {task_description}**
    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    
    **Complexity:** {complexity_icon} {complexity_level}
    
    **What I'll Do:**
    ✓ [Concrete deliverable 1]
    ✓ [Concrete deliverable 2]
    ✓ [Concrete deliverable 3]
    
    **What I Can't Do:**
    ✗ [Limitation 1] → Alternative: [workaround]
    ✗ [Limitation 2] → Alternative: [workaround]
    
    **What You'll Need To Do:**
    👤 [User action 1]
    👤 [User action 2]
    
    **Estimated Exchanges:** ~{total_exchanges}
    **Potential Challenges:** [Main risk or complexity]
    
    STEP 5: PROGRESS TRACKER INTEGRATION
    ===================================
    IF {auto_init_progress} == True:
        
        Extract steps from analysis:
        1. [First major step]
        2. [Second major step]
        3. [Third major step]
        ...
        
        #AI->H::Status: (Initializing progress tracking)
        
        Call PROGRESS_TRACKER with:
        - task_name: {task_description}
        - mode: "initialize"
        - steps_list: [extracted steps]
        
        Show integrated view:
        **Progress Tracking:** Active ✅
        **Current Status:** [░░░░░░░░░░] 0% - Ready to begin
        **First Step:** {step_1_description}
    
    STEP 6: CONFIRMATION REQUEST
    ============================
    
    #AI->H::Question: (Does this match your expectations? Should I proceed with this approach?)
    
    IF user wants changes:
        #AI->H::RequestingFeedback: (What aspects should I adjust?)
        
    IF user confirms:
        #AI->H::Status: (Beginning task with progress tracking active)
        Proceed to first step
    
    STEP 7: EXPECTATION ADJUSTMENTS
    ===============================
    During execution, if scope changes:
    
    #AI->H::Note: (Task complexity has increased due to [reason])
    #AI->H::Status: (Updating expectations:)
    - Original estimate: ~X exchanges
    - Revised estimate: ~Y exchanges
    - Reason: [specific discovery]
    
    Update PROGRESS_TRACKER accordingly
    
    COMMON PATTERNS:
    ===============
    
    Pattern 1: Simple Information Request
    "What is X?"
    - Complexity: ⚡ Simple
    - Deliverable: Clear explanation of X
    - Exchanges: ~1
    
    Pattern 2: Multi-Step Process
    "Create a complete Y"
    - Complexity: ⚙️ Moderate  
    - Deliverables: Planning, drafting, refining
    - Exchanges: ~5-7
    
    Pattern 3: Complex Integration
    "Implement Z with constraints A, B, C"
    - Complexity: 🏗️ Very Complex
    - Deliverables: Analysis, design, implementation, testing
    - Exchanges: ~10-15
    - Challenges: Constraint conflicts, platform limits
    
    #H->AI::OnError: (If unable to estimate, provide ranges with uncertainty levels)
    """
)


# USAGE EXAMPLES:
# ==============


# Simple task:
# User: "Explain CRAFT variables"
# Recipe produces:
# 📋 Task Overview: Explain CRAFT variables
# Complexity: ⚡ Simple
# What I'll Do: ✓ Explain variable types, syntax, and usage
# Estimated Exchanges: ~1


# Complex task:
# User: "Create a complete recipe for data validation"
# Recipe produces:
# 📋 Task Overview: Create complete recipe for data validation  
# Complexity: 🔧 Complex
# What I'll Do: 
# ✓ Analyze requirements
# ✓ Design recipe structure
# ✓ Write complete implementation
# ✓ Provide usage examples
# What I Can't Do:
# ✗ Test with real data → Alternative: Provide test cases
# Estimated Exchanges: ~8-10
# [Automatically initializes PROGRESS-TRACKER with steps]


# Integration example:
# EXPECTATION_SETTER initializes task breakdown
# PROGRESS_TRACKER monitors execution
# Both recipes share the same step list and update together




# =========================================================
# END RECIPE-ID: RCP-001-004-012-EXPECT-SET-v1.00a
# =========================================================










=========================================================
START RECIPE-ID: RCP-001-004-013-PROJECT-FILE-INFO-EXTRACTOR-v1.00a
=========================================================
pythonPROJECT_FILE_INFO_EXTRACTOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-013-PROJECT-FILE-INFO-EXTRACTOR-v1.00a",
    title="Project File Information Extractor for Cross-Project Persistence",
    description="Interactive recipe that collaboratively reviews project files to identify valuable patterns, functions, and insights that should persist to the framework or cookbook files for use in future projects",
    category="CAT-001",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "project_id": {
            "type": "string",
            "required": True,
            "description": "The project ID being concluded (e.g., CFT-PROJ-CP-022)"
        },
        "review_mode": {
            "type": "string",
            "required": False,
            "default": "comprehensive",
            "options": ["comprehensive", "focused", "quick"],
            "description": "Depth of analysis"
        },
        "include_handoffs": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Whether to analyze handoff history for patterns"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Conduct interactive review of project {project_id} for reusable content)
    #H->AI::Context: (This is a collaborative process - decisions made together)
    #H->AI::Structure: (Present findings, discuss value, determine destinations)
    
    STEP 0: INITIALIZATION
    ======================
    #AI->H::Status: (Initializing project review for {project_id})
    #AI->H::Note: (This process will help identify valuable patterns to preserve for future projects)
    
    Load and scan:
    - Project Implementation File
    - All Handoff Snapshots (if {include_handoffs})
    - Any test results or documentation
    
    STEP 1: CATEGORIZE DISCOVERABLE CONTENT
    =======================================
    #AI->H::Status: (Scanning project files for potentially reusable content)
    
    Categories to examine:
    
    **FUNCTIONS & METHODS**
    - New utility functions created
    - Improvements to existing functions
    - Novel function patterns
    
    **VARIABLE PATTERNS**
    - Useful configuration structures
    - Effective naming conventions
    - Multi-modal variable approaches
    
    **OBJECTS & CLASSES**
    - New object types created
    - Useful class patterns
    - Object composition strategies
    
    **WORKFLOW INNOVATIONS**
    - Process improvements discovered
    - Effective comment usage patterns
    - Handoff optimizations
    
    **RECIPE IDEAS**
    - Repeated procedures that could become recipes
    - Ad-hoc solutions worth formalizing
    - Patterns from successful interactions
    
    **LESSONS & INSIGHTS**
    - What worked particularly well
    - What challenges were overcome
    - Best practices discovered
    
    STEP 2: INITIAL SCAN RESULTS
    ============================
    #AI->H::Status: (Found the following potentially valuable content)
    
    [Present organized findings in categories]
    
    📁 **FUNCTIONS DISCOVERED:**
    1. [Function name] - [Brief description]
       Location: [Where found]
       Purpose: [What it does]
       Potential value: [Why it might be useful elsewhere]
    
    📊 **VARIABLE PATTERNS:**
    1. [Pattern name] - [Brief description]
       Example: [Show structure]
       Use case: [When this would help]
    
    🔧 **WORKFLOW INNOVATIONS:**
    1. [Innovation] - [What makes it valuable]
    
    [Continue for each category with findings]
    
    #AI->H::Question: (Which of these discoveries interest you most for preservation?)
    
    STEP 3: COLLABORATIVE EVALUATION
    ================================
    [For each item user shows interest in:]
    
    #AI->H::Status: (Examining: [Item name])
    
    **Full Context:**
    [Show the complete code/pattern/content]
    
    **Project-Specific vs. Generalizable:**
    - Project-specific elements: [List]
    - Generalizable aspects: [List]
    
    **Suggested Modifications for Reuse:**
    - [ ] Remove project-specific names
    - [ ] Add parameters for flexibility
    - [ ] Include usage documentation
    
    #AI->H::RequiredQuestion: (Should we extract this for framework use? If yes, what modifications needed?)
    
    STEP 4: DESTINATION PLANNING
    ============================
    [For each item marked for extraction:]
    
    #AI->H::Status: (Determining best location for: [Item])
    
    **Destination Options:**
    1. Framework Specification (CFT-FWK-SPEC)
       - Best for: Core functions, fundamental patterns
       - Section: [Suggest specific section]
    
    2. Cookbook File 
       - Best for: Recipes, repeatable procedures
       - Cookbook: [CORE/CONTENT/BUSINESS/CYBERSECURITY]
       - Rationale: [Why this cookbook]
    
    3. New Best Practices Document
       - Best for: Lessons learned, workflow tips
       - Format: [Suggest structure]
    
    #AI->H::RequiredQuestion: (Where should [Item] be placed? Option 1, 2, or 3?)
    
    STEP 5: NAMING CONFLICT RESOLUTION
    ==================================
    [If conflicts detected:]
    
    #AI->H::Caution: (Naming conflict detected for: [Item name])
    
    **Current Usage:**
    - In Project: [How it's used]
    - In Framework: [Existing similar item]
    
    **Renaming Options:**
    1. Prefix approach: PROJECT022_[Original_Name]
    2. Descriptive approach: [More_Specific_Name]
    3. Versioned approach: [Name]_v2
    4. Namespace approach: ProjectPatterns.[Name]
    
    #AI->H::RequiredQuestion: (Which naming approach do you prefer?)
    
    STEP 6: GENERATE EXTRACTION REPORT
    ==================================
    #AI->H::Status: (Creating extraction report with ready-to-paste sections)
    
    ## PROJECT {project_id} EXTRACTION REPORT
    
    **Extraction Date:** [Current date]
    **Items Identified:** [Total count]
    **Items Selected:** [Selected count]
    
    ### FOR FRAMEWORK SPECIFICATION:
    ```python
    # Add to Section [X]: [Section name]
    # Source: {project_id}
    # Added: [Date]
    
    [Formatted content ready to paste]
    ```
    
    ### FOR [COOKBOOK NAME] COOKBOOK:
    ```python
    # New Recipe: [Recipe name]
    # Source: {project_id}
    # Category: CAT-[XXX]
    
    [Formatted recipe content]
    ```
    
    ### FOR BEST PRACTICES:
    ```markdown
    ## [Practice name]
    Discovered in: {project_id}
    
    [Formatted insight/lesson]
    ```
    
    STEP 7: PRESERVATION CHECKLIST
    ==============================
    #AI->H::Status: (Final review before preservation)
    
    **Pre-Preservation Checklist:**
    □ All project-specific references removed
    □ Documentation added for each item
    □ Naming conflicts resolved
    □ Destination files identified
    □ Content formatted correctly
    
    **Items Ready for Preservation:**
    1. [Item] → [Destination] ✓
    2. [Item] → [Destination] ✓
    
    #AI->H::Note: (Copy the formatted sections above to preserve these discoveries)
    #AI->H::Question: (Any other patterns from {project_id} we should capture before concluding?)
    
    STEP 8: PROJECT WISDOM SUMMARY
    ==============================
    [Optional: Create a brief "wisdom summary"]
    
    ## Key Insights from {project_id}
    
    **Most Valuable Discovery:**
    [What was the biggest win]
    
    **Pattern That Emerged:**
    [What repeated pattern proved useful]
    
    **Lesson for Future Projects:**
    [What approach should be repeated]
    
    #AI->H::Note: (Project extraction complete - {project_id}'s innovations preserved!)
    
    #H->AI::OnError: (If files cannot be fully analyzed, focus on available content)
    """
)


# USAGE NOTES:
# ===========
# Run this recipe when concluding a project to ensure valuable discoveries
# don't get lost. The interactive nature ensures human judgment guides what
# gets promoted to framework level while AI assists in identifying patterns
# and formatting for reuse.
#
# Typical triggers:
# - "Let's extract useful patterns from this project"
# - "What from this project should we keep?"
# - "Time to conclude this project and save the good stuff"
=========================================================
END RECIPE-ID: RCP-001-004-013-PROJECT-FILE-INFO-EXTRACTOR-v1.00a
=========================================================












# =========================================================
# START RECIPE-ID: RCP-001-004-014-CRAFT-BRAINSTORMER-v1.00a
# =========================================================


```python
CRAFT_BRAINSTORMER_RECIPE = Recipe(
    recipe_id="RCP-001-004-014-CRAFT-BRAINSTORMER-v1.00a",
    title="CRAFT Framework Innovation Brainstormer",
    description="Structured ideation tool for generating and evaluating new CRAFT functionality ideas that align with core purposes and philosophical principles",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "focus_area": {
            "type": "string",
            "required": False,
            "default": "general",
            "options": ["general", "recipes", "persistence", "collaboration", "security", "usability", "performance"],
            "description": "Specific area to focus brainstorming efforts"
        },
        "num_ideas": {
            "type": "integer",
            "required": False,
            "default": 5,
            "min": 1,
            "max": 20,
            "description": "Number of ideas to generate"
        },
        "depth_level": {
            "type": "string",
            "required": False,
            "default": "detailed",
            "options": ["quick", "detailed", "comprehensive"],
            "description": "Level of detail for each idea"
        },
        "constraint_mode": {
            "type": "string",
            "required": False,
            "default": "practical",
            "options": ["blue_sky", "practical", "immediate"],
            "description": "Implementation feasibility constraints"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Generate {num_ideas} innovative CRAFT framework ideas focused on {focus_area})
    #H->AI::Context: (Each idea must improve core purposes and align with philosophical principles)
    #H->AI::Structure: (Use standardized format for consistent evaluation)
    
    BRAINSTORMING CONSTRAINTS:
    =======================
    Mode: {constraint_mode}
    - blue_sky: No implementation limits, focus on vision
    - practical: Consider current technical constraints
    - immediate: Only ideas implementable with existing framework
    
    IDEA GENERATION FRAMEWORK:
    ========================
    
    For each of the {num_ideas} ideas, structure as follows:
    
    📡 IDEA #[X]: [DESCRIPTIVE_NAME]
    ================================
    
    **WHAT IS IT?**
    [Concise description of the functionality/feature in 2-3 sentences]
    
    **WHICH PARTS OF CRAFT DOES THIS IDEA INVOLVE:**
    □ THE COOKBOOK.AI WEBSITE - [How it uses/enhances the website]
    □ THE HANDOFF FILE - [Impact on session continuity]
    □ THE COOKBOOK FILE - [New recipes or modifications needed]
    □ THE CRAFT SPECIFICATION - [Framework changes required]
    □ THE CRAFT PROJECT FILE - [Project-specific implementations]
    
    **WHAT CORE PHILOSOPHY AND GUIDING PRINCIPLES DOES IT IMPROVE?**
    
    Core Purpose Improvements:
    ✓ [Specific challenge addressed from the 5 core challenges]
    
    Philosophical Principles Enhanced:
    ✓ [1-3 principles from the 6 key principles]
    
    Fundamental Guiding Principles Advanced:
    ✓ [1-2 principles from the 5 fundamental principles]
    
    **HOW WOULD IT DO THIS?**
    [Technical explanation of implementation in {depth_level} detail]
    - Key mechanism: [Primary way it works]
    - User experience: [How users interact with it]
    - Integration points: [How it connects with existing CRAFT]
    
    **FOLLOW-UP IDEAS (2-5):**
    1. [Natural extension or enhancement]
    2. [Complementary feature]
    3. [Advanced capability building on this]
    4. [Integration with other CRAFT components]
    5. [Future evolution possibility]
    
    **INNOVATION SCORE:** [1-10]
    **FEASIBILITY SCORE:** [1-10]
    **IMPACT SCORE:** [1-10]
    
    ---
    
    EVALUATION CRITERIA:
    ===================
    
    When generating ideas, prioritize:
    
    1. SOLVING REAL PROBLEMS:
       - Does it address actual pain points from CP-005/CP-006?
       - Will users immediately understand the value?
    
    2. PHILOSOPHICAL ALIGNMENT:
       - Does it embody CRAFT's core principles?
       - Does it enhance rather than complicate?
    
    3. TECHNICAL ELEGANCE:
       - Can it be implemented cleanly?
       - Does it integrate naturally with existing components?
    
    4. TOKEN EFFICIENCY:
       - Does it reduce repetition?
       - Does it save tokens in practice?
    
    5. SCALABILITY:
       - Will it work for simple and complex use cases?
       - Can it grow with user needs?
    
    BRAINSTORMING THEMES FOR {focus_area}:
    ====================================
    
    IF focus_area == "general":
        Consider all aspects of CRAFT
    
    IF focus_area == "recipes":
        Focus on recipe creation, discovery, execution, composition
    
    IF focus_area == "persistence":
        Explore state management, variable storage, cross-session memory
    
    IF focus_area == "collaboration":
        Enhance multi-user, multi-AI, or team workflows
    
    IF focus_area == "security":
        Strengthen safety, validation, and protection mechanisms
    
    IF focus_area == "usability":
        Improve user experience, reduce learning curve
    
    IF focus_area == "performance":
        Optimize token usage, speed, efficiency
    
    CREATIVE PROMPTS:
    ================
    
    Ask yourself:
    - What if CRAFT could...?
    - How might we eliminate the need for...?
    - What would make users say "wow, that's exactly what I needed"?
    - How can we make the complex feel simple?
    - What patterns from {focus_area} could we standardize?
    
    #H->AI::OnError: (If struggling to generate ideas, review pain points from CP-005/CP-006 histories)
    """
)


# USAGE EXAMPLES:
# ==============


# Example 1: General brainstorming
execute_brainstorm = CRAFT_BRAINSTORMER_RECIPE.execute({
    "focus_area": "general",
    "num_ideas": 5,
    "depth_level": "detailed",
    "constraint_mode": "practical"
})


# Example 2: Blue-sky recipe innovations
execute_brainstorm = CRAFT_BRAINSTORMER_RECIPE.execute({
    "focus_area": "recipes",
    "num_ideas": 10,
    "depth_level": "quick",
    "constraint_mode": "blue_sky"
})


# Example 3: Immediate persistence improvements
execute_brainstorm = CRAFT_BRAINSTORMER_RECIPE.execute({
    "focus_area": "persistence",
    "num_ideas": 3,
    "depth_level": "comprehensive",
    "constraint_mode": "immediate"
})
```


# =========================================================
# END RECIPE-ID: RCP-001-004-014-CRAFT-BRAINSTORMER-v1.00a
# =========================================================






# =========================================================
# START RECIPE-ID: RCP-001-004-015-CRAFT-OPERATIONS-MANAGER-v1.02a
# =========================================================


CRAFT_OPERATIONS_MANAGER_RECIPE = Recipe(
    recipe_id="RCP-001-004-015-CRAFT-OPERATIONS-MANAGER-v1.02a",  # Version bump for Persona integration
    title="CRAFT Operations Manager - Automatic Recipe Detector with Prompt Framework and Persona Intelligence",
    description="Lightweight recipe that runs with every prompt to detect opportunities for using CRAFT recipes, framework components, and persona switching. Automatically executes appropriate recipes based on configured triggers.",
    category="CAT-001",
    subcategory="SUBCAT-Automation",
    difficulty="medium",
    
    parameters={
        "user_prompt": {
            "type": "string",
            "required": True,
            "description": "The user's prompt to analyze"
        },
        "mode": {
            "type": "string",
            "required": False,
            "default": "production",
            "options": ["production", "test"],
            "description": "Execution mode - production runs silently, test shows all reasoning"
        },
        "enable_promptfwks": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Enable prompt framework improvement suggestions"
        },
        "enable_persona_detection": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Enable persona switching detection and suggestions"
        },
        "current_persona": {
            "type": "object",
            "required": False,
            "default": "DEFAULT_CRAFT_PERSONA",
            "description": "The currently active persona object"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Run CRAFT-OPERATIONS-MANAGER analysis on '{user_prompt}')
    #H->AI::Context: (This runs automatically with EVERY prompt after CRAFT initialization)
    #H->AI::Constraint: (In production mode, execute silently unless action needed)
    
    # INITIALIZATION
    # =============
    CRAFT_PROMPT_ACTIVE = True
    CRAFT_PROMPT_MODE = "{mode}"
    DETECTED_TRIGGERS = []
    PROMPT_FWK_OPPORTUNITIES = []
    PERSONA_OPPORTUNITIES = []
    
    # CONVERSATION STATE TRACKING
    # ==========================
    CONVERSATION_STATE = {
        "token_usage": estimate_token_percentage(),
        "exchange_count": count_conversation_turns(),
        "current_recipe": identify_active_recipe(),
        "recent_errors": check_recent_errors(),
        "ambiguity_level": assess_ambiguity("{user_prompt}"),
        "task_complexity": evaluate_complexity("{user_prompt}"),
        "active_persona": {current_persona}
    }
    
    # RECIPE DETECTION ENGINE
    # ======================
    
    # 1. HANDOFF_SNAPSHOT Detection
    IF (CONVERSATION_STATE.token_usage >= 85):
        DETECTED_TRIGGERS.append({
            "recipe": "HANDOFF_SNAPSHOT",
            "priority": "URGENT",
            "action": "ASK_FIRST",
            "message": "⚠️ Approaching token limit (85%) - handoff recommended"
        })
    ELIF (CONVERSATION_STATE.token_usage >= 70 AND 
          any(phrase in user_prompt.lower() for phrase in ["goodbye", "that's all", "we're done", "end session"])):
        DETECTED_TRIGGERS.append({
            "recipe": "HANDOFF_SNAPSHOT",
            "priority": "HIGH",
            "action": "SUGGEST",
            "message": "Natural break point detected - consider creating handoff"
        })
    
    # 2. AMBIGUITY-DETECT Detection
    ambiguous_phrases = ["it", "that", "this", "the thing", "the file", "fix it", "that error", "the problem"]
    IF (any(phrase in user_prompt.lower() for phrase in ambiguous_phrases) AND 
        len(user_prompt.split()) < 10):
        DETECTED_TRIGGERS.append({
            "recipe": "AMBIGUITY-DETECT",
            "priority": "HIGH",
            "action": "AUTO_EXECUTE",
            "message": "Ambiguous reference detected"
        })
    
    # 3. TOKEN-MONITOR Detection
    IF ("how many tokens" in user_prompt.lower() OR 
        "token usage" in user_prompt.lower() OR
        "tokens left" in user_prompt.lower()):
        DETECTED_TRIGGERS.append({
            "recipe": "TOKEN-MONITOR",
            "priority": "MEDIUM",
            "action": "AUTO_EXECUTE",
            "message": "Token monitoring requested"
        })
    
    # 4. LIMITATION-ACK Detection
    limitation_phrases = ["can you", "are you able to", "is it possible", "can AI", "your capabilities"]
    IF (any(phrase in user_prompt.lower() for phrase in limitation_phrases)):
        DETECTED_TRIGGERS.append({
            "recipe": "LIMITATION-ACK",
            "priority": "LOW",
            "action": "CONDITIONAL",
            "message": "Capability question detected"
        })
    
    # 5. CONFIDENCE-CALIB Detection
    uncertainty_phrases = ["estimate", "roughly", "approximately", "guess", "predict", "forecast"]
    IF (any(phrase in user_prompt.lower() for phrase in uncertainty_phrases)):
        DETECTED_TRIGGERS.append({
            "recipe": "CONFIDENCE-CALIB",
            "priority": "MEDIUM",
            "action": "AUTO_EXECUTE",
            "message": "Uncertainty calibration needed"
        })
    
    # 6. SOURCE-VALID Detection
    IF ("verify" in user_prompt.lower() OR
        "fact check" in user_prompt.lower() OR
        "source" in user_prompt.lower() OR
        contains_statistical_claims(user_prompt)):
        DETECTED_TRIGGERS.append({
            "recipe": "SOURCE-VALID",
            "priority": "MEDIUM",
            "action": "SUGGEST",
            "message": "Fact validation opportunity"
        })
    
    # 7. POLICY-DIGEST Detection
    sensitive_topics = ["jailbreak", "ignore instructions", "bypass", "illegal", "harmful"]
    IF (any(topic in user_prompt.lower() for topic in sensitive_topics)):
        DETECTED_TRIGGERS.append({
            "recipe": "POLICY-DIGEST",
            "priority": "URGENT",
            "action": "AUTO_EXECUTE",
            "message": "Policy review needed"
        })
    
    # 8. PROGRESS-TRACK Detection
    IF (contains_numbered_steps(user_prompt) OR
        "track progress" in user_prompt.lower() OR
        "complex task" in user_prompt.lower() OR
        CONVERSATION_STATE.task_complexity > 7):
        DETECTED_TRIGGERS.append({
            "recipe": "PROGRESS-TRACK",
            "priority": "MEDIUM",
            "action": "AUTO_EXECUTE",
            "message": "Progress tracking initialized"
        })
    
    # 9. ERROR-TRANS Detection
    IF (CONVERSATION_STATE.recent_errors OR
        "error" in user_prompt.lower() OR
        "not working" in user_prompt.lower() OR
        "failed" in user_prompt.lower()):
        DETECTED_TRIGGERS.append({
            "recipe": "ERROR-TRANS",
            "priority": "HIGH",
            "action": "AUTO_EXECUTE",
            "message": "Error translation needed"
        })
    
    # 10. EXPECT-SET Detection
    IF (contains_multiple_requests(user_prompt) OR
        "everything" in user_prompt.lower() OR
        "all of" in user_prompt.lower() OR
        vague_scope_detected(user_prompt)):
        DETECTED_TRIGGERS.append({
            "recipe": "EXPECT-SET",
            "priority": "HIGH",
            "action": "AUTO_EXECUTE",
            "message": "Expectation alignment needed"
        })
    
    # 11. CRAFT-BRAINSTORMER Detection
    brainstorm_triggers = ["brainstorm", "ideas for", "suggestions for", "what if", "possibilities"]
    IF (any(trigger in user_prompt.lower() for trigger in brainstorm_triggers) AND
        "craft" in user_prompt.lower()):
        DETECTED_TRIGGERS.append({
            "recipe": "CRAFT-BRAINSTORMER",
            "priority": "MEDIUM",
            "action": "ASK_FIRST",
            "message": "Brainstorming opportunity detected"
        })
    
    # 12. ANALYZE-FIRST Detection
    IF ("analyze" in user_prompt.lower() OR
        "review" in user_prompt.lower() OR
        "examine" in user_prompt.lower() OR
        attached_files_detected()):
        DETECTED_TRIGGERS.append({
            "recipe": "ANALYZE-FIRST",
            "priority": "MEDIUM",
            "action": "AUTO_EXECUTE",
            "message": "Analysis needed before proceeding"
        })
    
    # 13. COM-UPDATER Detection
    IF ("update COM" in user_prompt or
        "update CRAFT-OPERATIONS-MANAGER" in user_prompt or
        "configure triggers" in user_prompt.lower()):
        DETECTED_TRIGGERS.append({
            "recipe": "COM-UPDATER",
            "priority": "HIGH",
            "action": "ASK_FIRST",
            "message": "COM configuration update requested"
        })
    
    # 14. PROMPTFWKS-WITHIN-CRAFT Detection
    # =====================================
    IF {enable_promptfwks}:
        # Check for prompt improvement opportunities
        prompt_clarity = assess_prompt_clarity("{user_prompt}")
        
        IF (prompt_clarity < 7 OR
            CONVERSATION_STATE.ambiguity_level > 0.3 OR
            "help me phrase" in user_prompt.lower() OR
            "how should I ask" in user_prompt.lower() OR
            "better way to say" in user_prompt.lower()):
            PROMPT_FWK_OPPORTUNITIES.append({
                "recipe": "PROMPTFWKS-WITHIN-CRAFT",
                "priority": "MEDIUM",
                "action": "SUGGEST",
                "message": "Prompt framework could improve clarity",
                "clarity_score": prompt_clarity
            })
        
        # Check for specific framework triggers
        framework_patterns = {
            "step by step": "CHAIN_OF_THOUGHT",
            "explore options": "TREE_OF_THOUGHTS",
            "debug": "REACT",
            "verify": "SELF_CONSISTENCY",
            "break down": "LEAST_TO_MOST"
        }
        
        for pattern, framework in framework_patterns.items():
            if pattern in user_prompt.lower():
                PROMPT_FWK_OPPORTUNITIES.append({
                    "recipe": "PROMPTFWKS-WITHIN-CRAFT",
                    "priority": "LOW",
                    "action": "NOTE",
                    "message": f"{framework} framework pattern detected",
                    "suggested_framework": framework
                })
    
    # NEW: 15. CRAFT-PERSONA-MGR Detection
    # ====================================
    IF {enable_persona_detection}:
        current_persona = CONVERSATION_STATE.active_persona
        prompt_lower = user_prompt.lower()
        
        # Check for explicit persona requests
        IF ("persona" in prompt_lower OR 
            "switch persona" in prompt_lower OR
            "change personality" in prompt_lower):
            PERSONA_OPPORTUNITIES.append({
                "recipe": "CRAFT-PERSONA-MGR",
                "priority": "HIGH",
                "action": "AUTO_EXECUTE",
                "message": "Explicit persona request detected",
                "trigger_context": "user_request"
            })
        
        # Check for implicit persona opportunities
        ELSE:
            # Define persona trigger patterns
            PERSONA_TRIGGERS = {
                "creative-writing-coach": ["writing", "story", "novel", "character", "plot", "poem", "creative", "fiction", "narrative"],
                "tech-support-specialist": ["error", "not working", "broken", "help with", "troubleshoot", "install", "configure", "setup", "fix"],
                "data-analyst": ["analyze data", "statistics", "metrics", "report", "dashboard", "correlation", "trend", "insight", "visualization"],
                "project-manager": ["project plan", "timeline", "milestone", "deliverable", "resource", "deadline", "team coordination"],
                "code-mentor": ["debug", "code review", "programming", "algorithm", "python", "javascript", "function", "class", "API"],
                "business-strategist": ["business plan", "market analysis", "competitive", "strategy", "growth", "revenue", "positioning", "SWOT"],
                "language-teacher": ["translate", "grammar", "pronunciation", "language learning", "conjugate", "vocabulary", "phrase in"],
                "research-assistant": ["research", "sources", "cite", "literature review", "academic", "scholarly", "peer-reviewed"],
                "wellness-coach": ["health", "wellness", "stress", "exercise", "nutrition", "habit", "lifestyle", "balance", "self-care"]
            }
            
            # Check each persona's triggers
            for persona_id, triggers in PERSONA_TRIGGERS.items():
                if any(trigger in prompt_lower for trigger in triggers):
                    # Calculate relevance score
                    relevance_score = calculate_persona_relevance(user_prompt, persona_id, triggers)
                    
                    # Only suggest if different from current and confidence is high
                    if persona_id != current_persona.id and relevance_score > 75:
                        PERSONA_OPPORTUNITIES.append({
                            "recipe": "CRAFT-PERSONA-MGR",
                            "priority": "MEDIUM",
                            "action": "DELAYED_SUGGEST",  # Don't interrupt current response
                            "message": f"{persona_id} persona may be helpful for this task",
                            "trigger_context": "task_detection",
                            "suggested_persona": persona_id,
                            "relevance_score": relevance_score
                        })
                        break  # Only suggest one persona per prompt
    
    # COOKBOOK EXTENSION DETECTION
    # ============================
    # Check for cookbook-specific patterns
    IF cookbook_loaded("CONTENT-AND-PROMO"):
        IF ("blog" in user_prompt.lower() OR
            "article" in user_prompt.lower() OR
            "documentation" in user_prompt.lower() OR
            "chart" in user_prompt.lower()):
            check_extension_recipe("COM-EXT-CAT002", user_prompt)
    
    # EXECUTION LOGIC
    # ==============
    
    # Combine all detection results
    ALL_TRIGGERS = DETECTED_TRIGGERS + PROMPT_FWK_OPPORTUNITIES + PERSONA_OPPORTUNITIES
    
    # Sort by priority
    PRIORITY_ORDER = {"URGENT": 1, "HIGH": 2, "MEDIUM": 3, "LOW": 4}
    ALL_TRIGGERS.sort(key=lambda x: PRIORITY_ORDER.get(x["priority"], 5))
    
    IF "{mode}" == "production":
        # PRODUCTION MODE - Execute silently
        DELAYED_SUGGESTIONS = []
        
        for trigger in ALL_TRIGGERS:
            IF trigger["action"] == "AUTO_EXECUTE":
                execute_recipe_silent(trigger["recipe"], trigger)
            ELIF trigger["action"] == "URGENT":
                #AI->H::COM::Urgent: ({trigger["message"]})
                #AI->H::Question: (Should I execute {trigger["recipe"]}?)
            ELIF trigger["action"] == "ASK_FIRST" AND trigger["priority"] == "HIGH":
                #AI->H::COM::Suggestion: ({trigger["message"]})
                #AI->H::Question: (Would you like me to run {trigger["recipe"]}?)
            ELIF trigger["action"] == "DELAYED_SUGGEST":
                # Queue for after main response
                DELAYED_SUGGESTIONS.append(trigger)
            ELIF trigger["recipe"] == "PROMPTFWKS-WITHIN-CRAFT" AND trigger["action"] == "SUGGEST":
                # Special handling for prompt framework suggestions
                #AI->H::PROMPT_FWK::Opportunity: (Your prompt clarity score: {trigger["clarity_score"]}/10. Would you like framework suggestions to improve it?)
        
        # Store delayed suggestions for after main response
        IF DELAYED_SUGGESTIONS:
            CONVERSATION_STATE["queued_suggestions"] = DELAYED_SUGGESTIONS
        
        # Status tracking
        IF len(ALL_TRIGGERS) == 0:
            #AI->H::COM::Status: (No triggers detected)
        ELSE:
            executed = [t["recipe"] for t in ALL_TRIGGERS if t["action"] == "AUTO_EXECUTE"]
            IF executed:
                #AI->H::COM::Status: (Auto-executed: {', '.join(executed)})
    
    ELIF "{mode}" == "test":
        # TEST MODE - Show all reasoning
        #AI->H::COM::TEST: (ANALYSIS COMPLETE)
        #AI->H::COM::TEST: (Detected {len(ALL_TRIGGERS)} total triggers)
        
        for trigger in ALL_TRIGGERS:
            #AI->H::COM::TEST: (
                Recipe: {trigger["recipe"]}
                Priority: {trigger["priority"]}
                Action: {trigger["action"]}
                Message: {trigger["message"]}
                Reasoning: {generate_reasoning(trigger)}
            )
            
            IF trigger["recipe"] == "PROMPTFWKS-WITHIN-CRAFT":
                #AI->H::PROMPT_FWK::TEST: (
                    Clarity Analysis:
                    - Current clarity: {trigger.get("clarity_score", "N/A")}/10
                    - Suggested framework: {trigger.get("suggested_framework", "To be determined")}
                    - Improvement potential: {calculate_improvement_potential()}%
                )
            
            IF trigger["recipe"] == "CRAFT-PERSONA-MGR":
                #AI->H::PERSONA::TEST: (
                    Persona Analysis:
                    - Current persona: {current_persona.name}
                    - Suggested persona: {trigger.get("suggested_persona", "To be determined")}
                    - Relevance score: {trigger.get("relevance_score", "N/A")}/100
                    - Trigger context: {trigger.get("trigger_context")}
                )
        
        # Show what would happen
        #AI->H::COM::TEST: (In production mode, these actions would occur:)
        for trigger in ALL_TRIGGERS:
            IF trigger["action"] == "AUTO_EXECUTE":
                #AI->H::COM::TEST: (- {trigger["recipe"]} would execute automatically)
            ELIF trigger["action"] == "ASK_FIRST":
                #AI->H::COM::TEST: (- You'd be asked about {trigger["recipe"]})
            ELIF trigger["action"] == "DELAYED_SUGGEST":
                #AI->H::COM::TEST: (- {trigger["recipe"]} would be suggested after main response)
    
    # POST-RESPONSE HANDLING
    # =====================
    # This section handles suggestions that should appear after the main response
    IF CONVERSATION_STATE.get("queued_suggestions"):
        for suggestion in CONVERSATION_STATE["queued_suggestions"]:
            IF suggestion["recipe"] == "CRAFT-PERSONA-MGR":
                append_to_response(f'''
                
                #AI->H::Suggestion: (Based on our discussion about {extract_task_description(user_prompt)}, 
                I could switch to a specialized persona for better assistance. 
                Would you like me to explain how the {suggestion["suggested_persona"]} persona could help?)
                ''')
    
    # CONTINUOUS MONITORING
    # ====================
    # Update conversation state for next prompt
    update_conversation_state({
        "triggers_detected": len(ALL_TRIGGERS),
        "recipes_executed": count_executed(),
        "prompt_frameworks_suggested": len(PROMPT_FWK_OPPORTUNITIES),
        "personas_suggested": len(PERSONA_OPPORTUNITIES),
        "token_checkpoint": CONVERSATION_STATE.token_usage
    })
    
    # HELPER FUNCTIONS
    # ===============
    def assess_prompt_clarity(prompt):
        # Evaluate prompt clarity on 1-10 scale
        score = 10
        if len(prompt.split()) < 5: score -= 2
        if "it" in prompt or "that" in prompt: score -= 1
        if no_clear_action_verb(prompt): score -= 2
        if multiple_unrelated_topics(prompt): score -= 2
        if lacks_context(prompt): score -= 1
        return max(1, score)
    
    def calculate_improvement_potential():
        # Estimate how much a framework could improve the prompt
        base_potential = (10 - prompt_clarity) * 10
        if high_complexity_task(): base_potential += 20
        if ambiguous_references(): base_potential += 15
        return min(100, base_potential)
    
    def calculate_persona_relevance(prompt, persona_id, triggers):
        # Calculate how relevant a persona is to the current task
        score = 0
        prompt_lower = prompt.lower()
        
        # Check trigger word matches
        for trigger in triggers:
            if trigger in prompt_lower:
                score += 15
        
        # Length and complexity bonus
        if len(prompt.split()) > 50:  # Longer prompts benefit from specialized personas
            score += 10
        
        # Technical content detection
        if any(char in prompt for char in ["()", "{}", "[]", "=>", "SELECT", "FROM"]):
            if persona_id in ["code-mentor", "data-analyst", "tech-support-specialist"]:
                score += 20
        
        # Creative content detection
        if any(word in prompt_lower for word in ["imagine", "create", "story", "describe"]):
            if persona_id == "creative-writing-coach":
                score += 20
        
        return min(score, 100)  # Cap at 100
    
    def extract_task_description(prompt):
        # Extract a brief description of the task for suggestions
        words = prompt.split()[:10]  # First 10 words
        return " ".join(words) + ("..." if len(prompt.split()) > 10 else "")
    
    #H->AI::OnError: (Continue without COM features - do not break user flow)
    """
)


# =========================================================
# END RECIPE-ID: RCP-001-004-015-CRAFT-OPERATIONS-MANAGER-v1.02a
# =========================================================


# USAGE EXAMPLES:
# ==============


# Example 1: Production mode (default)
execute_com = CRAFT_OPERATIONS_MANAGER_RECIPE.execute({
    "user_prompt": "I need help writing a fantasy novel about dragons",
    "current_persona": SESSION.ACTIVE_PERSONA
})
# Would detect creative writing task and queue persona suggestion


# Example 2: Test mode to see all detections
execute_com = CRAFT_OPERATIONS_MANAGER_RECIPE.execute({
    "user_prompt": "debug this python code that's not working",
    "mode": "test",
    "current_persona": SESSION.ACTIVE_PERSONA
})
# Would show analysis for code-mentor persona, error detection, etc.


# Example 3: With features disabled
execute_com = CRAFT_OPERATIONS_MANAGER_RECIPE.execute({
    "user_prompt": "analyze sales data trends",
    "enable_promptfwks": False,
    "enable_persona_detection": False
})
# Would only check standard recipe triggers


# CONFIGURATION NOTES:
# ===================
# This recipe is automatically executed after CHAT-INIT completes
# It runs silently in production mode unless user action is needed
# Persona suggestions are delayed to avoid interrupting responses
# All triggers are prioritized and sorted before execution








# =========================================================
# END RECIPE-ID: RCP-001-004-015-CRAFT-OPERATIONS-MANAGER-v1.02a
# =========================================================











# =========================================================
# START RECIPE-ID: RCP-001-004-016-v1.00a
# =========================================================  


PROMPTFWKS_WITHIN_CRAFT_RECIPE = Recipe(
    recipe_id="RCP-001-004-016-PROMPTFWKS-WITHIN-CRAFT-v1.00a",
    title="Prompt Framework Intelligence Assistant for CRAFT",
    description="Analyzes prompts and suggests optimal prompt crafting frameworks to improve communication clarity and effectiveness. Embeds knowledge of 20 popular frameworks with intelligent recommendations based on task type.",
    category="CAT-001",
    subcategory="SUBCAT-Communication",
    difficulty="medium",
    
    parameters={
        "user_prompt": {
            "type": "string",
            "required": True,
            "description": "The prompt to analyze for framework opportunities"
        },
        "task_context": {
            "type": "string",
            "required": False,
            "description": "Additional context about the task (e.g., 'recipe_creation', 'debugging', 'analysis')"
        },
        "learning_mode": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Whether to explain framework selection reasoning"
        },
        "auto_suggest": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Whether to automatically suggest when opportunities detected"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Analyze prompt for framework improvement opportunities)
    #H->AI::Context: (You are the Prompt Framework Intelligence Assistant)
    
    # EMBEDDED FRAMEWORK KNOWLEDGE BASE
    # =================================
    
    PROMPT_FRAMEWORKS = {
        "CHAIN_OF_THOUGHT": {
            "name": "Chain-of-Thought (CoT)",
            "description": "Break down complex problems into sequential reasoning steps",
            "best_for": ["mathematical problems", "logical reasoning", "complex analysis", "multi-step tasks"],
            "trigger_patterns": ["calculate", "analyze step by step", "explain your reasoning", "work through"],
            "example_pattern": "Let's think step by step: 1) First... 2) Then... 3) Finally...",
            "craft_contexts": ["recipe debugging", "complex function creation", "workflow design"],
            "effectiveness": 0.85,
            "complexity": "low"
        },
        
        "TREE_OF_THOUGHTS": {
            "name": "Tree of Thoughts (ToT)",
            "description": "Explore multiple reasoning paths and evaluate them",
            "best_for": ["creative problem solving", "strategic planning", "exploring alternatives", "complex decisions"],
            "trigger_patterns": ["explore options", "consider alternatives", "what are the possibilities", "evaluate approaches"],
            "example_pattern": "Consider three approaches: A) [approach]... B) [approach]... C) [approach]... Evaluating each...",
            "craft_contexts": ["recipe architecture", "framework design", "optimization strategies"],
            "effectiveness": 0.90,
            "complexity": "high"
        },
        
        "REACT": {
            "name": "ReAct (Reasoning + Acting)",
            "description": "Combine reasoning with action steps iteratively",
            "best_for": ["debugging", "interactive tasks", "tool usage", "real-time problem solving"],
            "trigger_patterns": ["debug this", "fix the error", "troubleshoot", "iterate until"],
            "example_pattern": "Thought: [reasoning] → Action: [step] → Observation: [result] → Repeat",
            "craft_contexts": ["error resolution", "recipe testing", "iterative improvement"],
            "effectiveness": 0.88,
            "complexity": "medium"
        },
        
        "SELF_CONSISTENCY": {
            "name": "Self-Consistency",
            "description": "Generate multiple solutions and find consensus",
            "best_for": ["validation", "accuracy improvement", "reducing hallucination", "fact checking"],
            "trigger_patterns": ["verify this", "double check", "ensure accuracy", "validate"],
            "example_pattern": "Approach 1: [solution]... Approach 2: [solution]... Approach 3: [solution]... Consensus: [final]",
            "craft_contexts": ["SOURCE-VALID enhancement", "fact verification", "quality assurance"],
            "effectiveness": 0.92,
            "complexity": "medium"
        },
        
        "LEAST_TO_MOST": {
            "name": "Least-to-Most",
            "description": "Decompose complex problems into simpler subproblems",
            "best_for": ["complex calculations", "hierarchical tasks", "learning new concepts", "building understanding"],
            "trigger_patterns": ["break this down", "start simple", "build up to", "decompose"],
            "example_pattern": "Subproblem 1: [simple]... Solve... Subproblem 2: [harder]... Solve... Main problem: [complex]",
            "craft_contexts": ["learning CRAFT", "complex recipe creation", "framework understanding"],
            "effectiveness": 0.87,
            "complexity": "medium"
        },
        
        "MAIEUTIC": {
            "name": "Maieutic Prompting",
            "description": "Use Socratic questioning to reach deeper understanding",
            "best_for": ["deep analysis", "uncovering assumptions", "philosophical reasoning", "critical thinking"],
            "trigger_patterns": ["question assumptions", "dig deeper", "what's really happening", "challenge this"],
            "example_pattern": "Initial claim: [X]. But is [X] always true? What if [Y]? This suggests...",
            "craft_contexts": ["framework philosophy", "design decisions", "architectural choices"],
            "effectiveness": 0.83,
            "complexity": "high"
        },
        
        "GENERATED_KNOWLEDGE": {
            "name": "Generated Knowledge",
            "description": "Generate relevant knowledge before answering",
            "best_for": ["knowledge-intensive tasks", "fact-based responses", "educational content", "documentation"],
            "trigger_patterns": ["explain", "teach me about", "document", "what do we know about"],
            "example_pattern": "Background: [generate context]... Given this knowledge: [apply to question]",
            "craft_contexts": ["documentation creation", "blog posts", "educational content"],
            "effectiveness": 0.86,
            "complexity": "low"
        },
        
        "PROMPT_CHAINING": {
            "name": "Prompt Chaining",
            "description": "Chain multiple prompts where outputs feed into next inputs",
            "best_for": ["workflows", "multi-stage processes", "complex transformations", "pipeline tasks"],
            "trigger_patterns": ["then", "after that", "multi-step", "workflow"],
            "example_pattern": "Step 1: [task] → Output → Step 2: Using [output], [next task] → Continue",
            "craft_contexts": ["recipe sequences", "workflow automation", "complex processes"],
            "effectiveness": 0.89,
            "complexity": "medium"
        },
        
        "DIRECTIONAL_STIMULUS": {
            "name": "Directional Stimulus",
            "description": "Include hints or cues to guide reasoning",
            "best_for": ["guided exploration", "specific focus areas", "avoiding tangents", "targeted analysis"],
            "trigger_patterns": ["focus on", "specifically", "pay attention to", "emphasize"],
            "example_pattern": "Analyze [X], particularly focusing on [specific aspect]. Key consideration: [hint]",
            "craft_contexts": ["targeted debugging", "specific improvements", "focused analysis"],
            "effectiveness": 0.84,
            "complexity": "low"
        },
        
        "ROLE_PROMPTING": {
            "name": "Role Prompting",
            "description": "Assign specific role or expertise perspective",
            "best_for": ["expert analysis", "specialized knowledge", "perspective taking", "professional output"],
            "trigger_patterns": ["as a", "from perspective of", "expert in", "act as"],
            "example_pattern": "As a [role/expert], analyze this: [task]. Consider [role-specific factors]",
            "craft_contexts": ["persona creation", "specialized recipes", "expert systems"],
            "effectiveness": 0.82,
            "complexity": "low"
        },
        
        "FEW_SHOT": {
            "name": "Few-Shot Learning",
            "description": "Provide examples to demonstrate desired pattern",
            "best_for": ["pattern matching", "format specification", "style mimicking", "consistent output"],
            "trigger_patterns": ["like this", "following format", "similar to", "examples"],
            "example_pattern": "Example 1: [input] → [output]. Example 2: [input] → [output]. Now: [actual task]",
            "craft_contexts": ["recipe examples", "format templates", "pattern establishment"],
            "effectiveness": 0.91,
            "complexity": "low"
        },
        
        "ZERO_SHOT_COT": {
            "name": "Zero-Shot Chain-of-Thought",
            "description": "Trigger step-by-step reasoning without examples",
            "best_for": ["general reasoning", "new problems", "thinking aloud", "transparent logic"],
            "trigger_patterns": ["think step by step", "reason through", "work it out", "show your thinking"],
            "example_pattern": "Let's think step by step about this problem...",
            "craft_contexts": ["general problem solving", "new recipe types", "unfamiliar tasks"],
            "effectiveness": 0.83,
            "complexity": "low"
        },
        
        "ANALOGICAL": {
            "name": "Analogical Reasoning",
            "description": "Use analogies to transfer knowledge between domains",
            "best_for": ["explaining concepts", "creative solutions", "knowledge transfer", "understanding"],
            "trigger_patterns": ["like", "similar to", "by analogy", "compare to"],
            "example_pattern": "This is like [familiar concept]. Just as [analogy], here we [application]",
            "craft_contexts": ["explaining CRAFT", "concept teaching", "framework analogies"],
            "effectiveness": 0.81,
            "complexity": "medium"
        },
        
        "EMOTION_PROMPTING": {
            "name": "Emotion Prompting",
            "description": "Add emotional context for enhanced engagement",
            "best_for": ["creative writing", "empathetic responses", "motivation", "engagement"],
            "trigger_patterns": ["feel", "emotional", "passionate about", "care about"],
            "example_pattern": "This is really important to me because [emotion/stake]. Please [task with care]",
            "craft_contexts": ["user experience", "motivation messages", "engagement features"],
            "effectiveness": 0.79,
            "complexity": "low"
        },
        
        "CONSTITUTIONAL_AI": {
            "name": "Constitutional AI",
            "description": "Apply principles and self-critique for alignment",
            "best_for": ["ethical decisions", "value alignment", "safety checks", "principle adherence"],
            "trigger_patterns": ["ensure safe", "align with principles", "check ethics", "follow guidelines"],
            "example_pattern": "Principle: [rule]. Response: [attempt]. Critique: [evaluate]. Revision: [improve]",
            "craft_contexts": ["recipe safety", "CRAFT principles", "framework alignment"],
            "effectiveness": 0.88,
            "complexity": "high"
        },
        
        "METACOGNITIVE": {
            "name": "Metacognitive Prompting",
            "description": "Reflect on own thinking process",
            "best_for": ["self-improvement", "bias detection", "quality assessment", "learning"],
            "trigger_patterns": ["reflect on", "evaluate thinking", "assess approach", "meta-analysis"],
            "example_pattern": "My approach: [method]. Evaluating: [strengths/weaknesses]. Better approach: [improved]",
            "craft_contexts": ["recipe improvement", "framework evolution", "self-assessment"],
            "effectiveness": 0.85,
            "complexity": "high"
        },
        
        "STRUCTURED_OUTPUT": {
            "name": "Structured Output",
            "description": "Define exact output format and structure",
            "best_for": ["data extraction", "formatting", "consistent output", "parsing"],
            "trigger_patterns": ["format as", "structure like", "output JSON", "table format"],
            "example_pattern": "Output format: {field1: [type], field2: [type]}. Result must match structure",
            "craft_contexts": ["data recipes", "report generation", "structured responses"],
            "effectiveness": 0.90,
            "complexity": "low"
        },
        
        "RECURSIVE": {
            "name": "Recursive Prompting",
            "description": "Apply same process recursively to refine",
            "best_for": ["iterative improvement", "refinement", "optimization", "depth"],
            "trigger_patterns": ["refine further", "go deeper", "iterate", "recursive"],
            "example_pattern": "Iteration 1: [result]. Applying again: [refined]. Continuing until: [criteria]",
            "craft_contexts": ["recipe optimization", "quality improvement", "deep analysis"],
            "effectiveness": 0.86,
            "complexity": "high"
        },
        
        "CONTRASTIVE": {
            "name": "Contrastive Prompting",
            "description": "Compare what to do vs what not to do",
            "best_for": ["clarification", "boundary setting", "avoiding errors", "precision"],
            "trigger_patterns": ["not", "avoid", "instead of", "rather than"],
            "example_pattern": "DO: [correct approach]. DON'T: [wrong approach]. Because: [reasoning]",
            "craft_contexts": ["error prevention", "clear guidelines", "recipe constraints"],
            "effectiveness": 0.87,
            "complexity": "low"
        },
        
        "SYNTHETIC_PROMPTING": {
            "name": "Synthetic Prompting",
            "description": "Generate synthetic examples for better understanding",
            "best_for": ["data augmentation", "edge cases", "testing", "comprehensive coverage"],
            "trigger_patterns": ["generate examples", "create test cases", "synthetic data", "edge cases"],
            "example_pattern": "Generate 5 examples: [criteria]. Test with: [synthetic cases]. Pattern: [learned]",
            "craft_contexts": ["recipe testing", "edge case handling", "test generation"],
            "effectiveness": 0.84,
            "complexity": "medium"
        }
    }
    
    # TASK CONTEXT MAPPINGS
    # ====================
    TASK_FRAMEWORK_PREFERENCES = {
        "recipe_creation": ["TREE_OF_THOUGHTS", "LEAST_TO_MOST", "FEW_SHOT"],
        "debugging": ["REACT", "CHAIN_OF_THOUGHT", "METACOGNITIVE"],
        "documentation": ["GENERATED_KNOWLEDGE", "STRUCTURED_OUTPUT", "FEW_SHOT"],
        "analysis": ["CHAIN_OF_THOUGHT", "SELF_CONSISTENCY", "MAIEUTIC"],
        "workflow": ["PROMPT_CHAINING", "LEAST_TO_MOST", "DIRECTIONAL_STIMULUS"],
        "creative": ["TREE_OF_THOUGHTS", "ANALOGICAL", "EMOTION_PROMPTING"],
        "validation": ["SELF_CONSISTENCY", "CONSTITUTIONAL_AI", "CONTRASTIVE"],
        "learning": ["LEAST_TO_MOST", "GENERATED_KNOWLEDGE", "ANALOGICAL"],
        "optimization": ["RECURSIVE", "METACOGNITIVE", "TREE_OF_THOUGHTS"],
        "testing": ["SYNTHETIC_PROMPTING", "CONTRASTIVE", "SELF_CONSISTENCY"]
    }
    
    # STEP 1: ANALYZE PROMPT
    # ======================
    #AI->H::Status: (Analyzing prompt for framework opportunities)
    
    prompt_analysis = {
        "clarity_score": assess_prompt_clarity("{user_prompt}"),
        "complexity": assess_complexity("{user_prompt}"),
        "task_type": identify_task_type("{user_prompt}", "{task_context}"),
        "ambiguity_points": find_ambiguities("{user_prompt}"),
        "improvement_potential": calculate_improvement_potential()
    }
    
    # STEP 2: IDENTIFY APPLICABLE FRAMEWORKS
    # ======================================
    applicable_frameworks = []
    
    for framework_id, framework in PROMPT_FRAMEWORKS.items():
        score = 0
        
        # Check trigger patterns
        for pattern in framework["trigger_patterns"]:
            if pattern.lower() in "{user_prompt}".lower():
                score += 0.3
        
        # Check task context alignment
        if "{task_context}" in TASK_FRAMEWORK_PREFERENCES:
            if framework_id in TASK_FRAMEWORK_PREFERENCES["{task_context}"]:
                score += 0.5
        
        # Check complexity match
        if matches_complexity(framework["complexity"], prompt_analysis["complexity"]):
            score += 0.2
        
        # Check CRAFT context relevance
        for craft_context in framework["craft_contexts"]:
            if craft_context in "{user_prompt}" or craft_context == "{task_context}":
                score += 0.4
        
        if score > 0.5:
            applicable_frameworks.append({
                "framework": framework_id,
                "score": score,
                "effectiveness": framework["effectiveness"],
                "details": framework
            })
    
    # Sort by score
    applicable_frameworks.sort(key=lambda x: x["score"] * x["effectiveness"], reverse=True)
    
    # STEP 3: GENERATE RECOMMENDATIONS
    # ================================
    IF len(applicable_frameworks) > 0:
        top_framework = applicable_frameworks[0]
        alternatives = applicable_frameworks[1:3] if len(applicable_frameworks) > 1 else []
        
        #AI->H::PROMPT_FWK::Recommendation: (
            Detected opportunity to improve prompt clarity using {top_framework["details"]["name"]}
            
            **Current Prompt Analysis:**
            - Clarity: {prompt_analysis["clarity_score"]}/10
            - Complexity: {prompt_analysis["complexity"]}
            - Improvement Potential: {prompt_analysis["improvement_potential"]}%
            
            **Recommended Framework: {top_framework["details"]["name"]}**
            {top_framework["details"]["description"]}
            
            **Why this framework?**
            - Best for: {', '.join(top_framework["details"]["best_for"])}
            - Effectiveness: {top_framework["effectiveness"]*100}%
            - Complexity: {top_framework["details"]["complexity"]}
            
            **Suggested Restructure:**
            ```
            {generate_restructured_prompt(user_prompt, top_framework)}
            ```
        )
        
        IF len(alternatives) > 0:
            #AI->H::PROMPT_FWK::Alternatives: (
                Alternative frameworks to consider:
                {format_alternatives(alternatives)}
            )
        
        IF {learning_mode}:
            #AI->H::PROMPT_FWK::Learning: (
                **Understanding {top_framework["details"]["name"]}:**
                
                This framework works by {explain_framework_mechanism(top_framework)}.
                
                In CRAFT contexts, it's particularly useful for:
                {format_craft_contexts(top_framework["details"]["craft_contexts"])}
                
                Example pattern: {top_framework["details"]["example_pattern"]}
                
                Tips for using this framework:
                {generate_framework_tips(top_framework)}
            )
        
        #AI->H::Question: (Would you like me to apply the {top_framework["details"]["name"]} framework to restructure your prompt?)
        
    ELSE:
        #AI->H::PROMPT_FWK::Status: (Prompt is already well-structured - no framework improvements needed)
    
    # STEP 4: TRACK USAGE PATTERNS
    # ============================
    # Store which frameworks are most useful for future recommendations
    IF framework_applied:
        track_framework_usage({
            "framework": selected_framework,
            "context": task_context,
            "effectiveness": user_feedback,
            "prompt_type": prompt_analysis["task_type"]
        })
    
    # HELPER FUNCTIONS (Conceptual)
    # =============================
    def assess_prompt_clarity(prompt):
        # Check for specific vs vague language
        # Check for clear objectives
        # Check for defined constraints
        return clarity_score
    
    def generate_restructured_prompt(original, framework):
        # Apply framework pattern to original prompt
        # Maintain intent while adding structure
        return restructured_prompt
    
    def explain_framework_mechanism(framework):
        # Provide clear explanation of how framework works
        # Use simple language and examples
        return explanation
    
    #H->AI::OnError: (If no frameworks apply, continue with original prompt without modification)
    """
)








# =========================================================
# END RECIPE-ID: RCP-001-004-016-v1.00a
# =========================================================  





# =========================================================
# START RECIPE-ID: RCP-001-004-017-COM-UPDATER-v1.00a
# =========================================================


COM_UPDATER_RECIPE = Recipe(
    recipe_id="RCP-001-004-017-COM-UPDATER-v1.00a",
    title="CRAFT-OPERATIONS-MANAGER Recipe Updater - Interactive Configuration Tool",
    description="Systematically reviews all cookbook recipes one-by-one to update CRAFT-OPERATIONS-MANAGER trigger conditions. Uses the same Q&A format with pauses between each recipe for user feedback.",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "starting_recipe": {
            "type": "integer",
            "required": False,
            "default": 1,
            "description": "Which recipe number to start from (useful for resuming)"
        },
        "include_new_recipes": {
            "type": "boolean",
            "required": False,
            "default": True,
            "description": "Include recipes added since CRAFT-OPERATIONS-MANAGER creation"
        },
        "output_format": {
            "type": "string",
            "required": False,
            "default": "full_recipe",
            "options": ["full_recipe", "triggers_only", "diff_view"],
            "description": "Format for the final output"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Review each cookbook recipe systematically for CRAFT-OPERATIONS-MANAGER updates)
    #H->AI::Context: (Use interactive Q&A format with pauses between recipes)
    #H->AI::Structure: (One recipe at a time, wait for feedback before proceeding)
    
    STEP 0: INITIALIZATION
    ======================
    #AI->H::Status: (Initializing COM_UPDATER for CRAFT-OPERATIONS-MANAGER configuration)
    
    # Load current cookbook recipes
    COOKBOOK_RECIPES = load_all_cookbook_recipes()
    TOTAL_RECIPES = len(COOKBOOK_RECIPES)
    CURRENT_POSITION = {starting_recipe}
    
    # Track configuration decisions
    RECIPE_CONFIGURATIONS = {}
    
    #AI->H::Note: (Found {TOTAL_RECIPES} recipes in cookbook)
    #AI->H::Note: (Starting from recipe {CURRENT_POSITION})
    
    STEP 1: EXPLAIN PROCESS
    =======================
    #AI->H::Note: (I'll analyze each recipe one at a time for CRAFT-OPERATIONS-MANAGER integration)
    #AI->H::Note: (For each recipe, I'll propose trigger conditions and ask questions)
    #AI->H::Note: (Your feedback will shape the final CRAFT-OPERATIONS-MANAGER configuration)
    
    #AI->H::Question: (Ready to begin with recipe {CURRENT_POSITION}?)
    
    [WAIT FOR USER CONFIRMATION]
    
    STEP 2: ITERATIVE RECIPE ANALYSIS
    =================================
    
    WHILE CURRENT_POSITION <= TOTAL_RECIPES:
        recipe = COOKBOOK_RECIPES[CURRENT_POSITION - 1]
        
        #AI->H::Status: (Analyzing Recipe {CURRENT_POSITION} of {TOTAL_RECIPES})
        
        ## Recipe {CURRENT_POSITION}: {recipe.title} ({recipe.recipe_id})
        
        **Current Purpose:** {recipe.description}
        
        ### Proposed Automatic Trigger Conditions:
        
        {generate_trigger_proposals(recipe)}
        
        ### Questions for {recipe.name}:
        
        {generate_recipe_questions(recipe)}
        
        ### Proposed Logic for CRAFT-OPERATIONS-MANAGER:
        ```
        {generate_proposed_logic(recipe)}
        ```
        
        #AI->H::Status: (Waiting for your feedback on {recipe.name} triggers before proceeding to recipe {CURRENT_POSITION + 1})
        
        [WAIT FOR USER FEEDBACK]
        
        # Process user feedback
        user_feedback = capture_user_responses()
        RECIPE_CONFIGURATIONS[recipe.recipe_id] = process_feedback(user_feedback)
        
        #AI->H::Note: (Acknowledging feedback on {recipe.name} - {summarize_decisions(user_feedback)})
        
        ## Updated Recipe {CURRENT_POSITION}: {recipe.name} Logic
        
        ### Refined Automatic Trigger Logic:
        ```
        {generate_refined_logic(recipe, user_feedback)}
        ```
        
        #AI->H::Note: ({recipe.name} configuration complete - {summary_of_config})
        
        # Increment position
        CURRENT_POSITION += 1
        
        IF CURRENT_POSITION <= TOTAL_RECIPES:
            #AI->H::Note: (Moving to next recipe...)
            #AI->H::Status: (---) # Visual separator
    
    STEP 3: CONFIGURATION SUMMARY
    =============================
    #AI->H::Status: (Completed configuration for all {TOTAL_RECIPES} recipes)
    
    ### Configuration Summary:
    {generate_configuration_summary(RECIPE_CONFIGURATIONS)}
    
    #AI->H::Question: (Ready to generate the updated CRAFT_PROMPT_RECIPE?)
    
    [WAIT FOR CONFIRMATION]
    
    STEP 4: GENERATE UPDATED CRAFT_PROMPT
    ====================================
    #AI->H::Status: (Generating updated CRAFT_PROMPT_RECIPE with all configurations)
    
    {generate_updated_craft_prompt(RECIPE_CONFIGURATIONS, output_format)}
    
    STEP 5: VERIFICATION
    ===================
    #AI->H::Status: (Updated CRAFT_PROMPT_RECIPE generation complete)
    
    ### Key Changes from Original:
    {list_key_changes(RECIPE_CONFIGURATIONS)}
    
    #AI->H::RequestingFeedback: (Would you like to test any specific trigger scenarios?)
    
    # HELPER FUNCTIONS
    # ================
    
    def generate_trigger_proposals(recipe):
        '''
        Analyze recipe purpose and suggest trigger conditions
        Returns formatted list of proposed triggers
        '''
        # Analyze recipe type and purpose
        # Suggest 3-5 trigger conditions
        # Format as numbered list with explanations
        
    def generate_recipe_questions(recipe):
        '''
        Generate 2-4 questions about trigger configuration
        Follows pattern from original session:
        - RequiredQuestion for critical decisions
        - OptionalQuestion for fine-tuning
        '''
        questions = []
        questions.append("#AI->H::RequiredQuestion: (Primary trigger question)")
        questions.append("#AI->H::RequiredQuestion: (Secondary decision point)")
        questions.append("#AI->H::OptionalQuestion: (Fine-tuning option)")
        return questions
        
    def process_feedback(feedback):
        '''
        Convert user feedback into configuration decisions
        '''
        config = {
            "triggers": extract_trigger_decisions(feedback),
            "mode": extract_mode_decision(feedback),
            "threshold": extract_threshold_decision(feedback),
            "additional_logic": extract_special_cases(feedback)
        }
        return config
        
    def generate_updated_craft_prompt(configs, format):
        '''
        Create complete updated CRAFT_PROMPT_RECIPE
        Incorporates all configuration decisions
        '''
        if format == "full_recipe":
            # Generate complete recipe definition
            return full_craft_prompt_recipe(configs)
        elif format == "triggers_only":
            # Just the trigger logic sections
            return trigger_logic_only(configs)
        elif format == "diff_view":
            # Show changes from original
            return diff_view(original_craft_prompt, configs)
    
    # QUESTION TEMPLATES
    # ==================
    
    STANDARD_QUESTIONS = {
        "trigger_threshold": "#AI->H::RequiredQuestion: (Should {recipe} trigger on [condition], or wait for [stronger_condition]?)",
        "auto_vs_ask": "#AI->H::RequiredQuestion: (When triggered, should it [auto_action] or ask '[prompt_text]'?)",
        "scope": "#AI->H::OptionalQuestion: (Should this apply to [narrow_scope] or [broad_scope]?)",
        "memory": "#AI->H::OptionalQuestion: (Should the recipe remember [tracked_item] to avoid [repetition]?)"
    }
    
    #H->AI::OnError: (If user wants to skip a recipe, note as "User skipped - no changes")
    """
)


# USAGE EXAMPLES:
# ==============


# Start fresh review of all recipes
execute_updater = COM_UPDATER_RECIPE.execute({
    "starting_recipe": 1,
    "include_new_recipes": True,
    "output_format": "full_recipe"
})


# Resume from recipe 8
execute_updater = COM_UPDATER_RECIPE.execute({
    "starting_recipe": 8,
    "output_format": "full_recipe"
})


# Just review new recipes added since CRAFT-OPERATIONS-MANAGER
execute_updater = COM_UPDATER_RECIPE.execute({
    "starting_recipe": 15,  # After CRAFT-OPERATIONS-MANAGER
    "output_format": "triggers_only"
})


# Get a diff view of changes
execute_updater = COM_UPDATER_RECIPE.execute({
    "starting_recipe": 1,
    "output_format": "diff_view"
})


# =========================================================
# END RECIPE-ID: RCP-001-004-017-COM-UPDATER-v1.00a
# =========================================================




# =========================================================
# MERGED RECIPE-ID: RCP-001-004-018-PROJECT-CREATOR-v3.00a
# =========================================================


PROJECT_CREATOR_RECIPE = Recipe(
    recipe_id="RCP-001-004-018-PROJECT-CREATOR-v3.00a",
    title="CRAFT Project File Generator with Template Processing",
    description="Interactive recipe creating project files through comprehensive discovery, template processing, and optional research prompt generation",
    category="CAT-001-CORE",
    difficulty="intermediate",
    version="3.00a",  # Merged version combining v1 and v2 functionality
    
    parameters={
        "templates_loaded": {
            "type": "list",
            "required": False,
            "description": "Pre-loaded template files from CHAT-INIT"
        },
        "project_id": {
            "type": "string",
            "required": False,
            "description": "Project ID if known"
        },
        "mode": {
            "type": "string",
            "required": False,
            "default": "template_based",
            "options": ["template_based", "from_scratch"],
            "description": "Creation mode"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Create CRAFT project files through comprehensive discovery)
    #H->AI::Context: (Acting as master prompt engineer and CRAFT framework expert)
    
    # ==========================================
    # STEP 1: TEMPLATE DETECTION & PARSING
    # ==========================================
    
    #AI->H::Status: (Checking for master templates)
    
    if templates_loaded:
        #AI->H::Note: (Found master template files)
        #AI->H::Note: (Will use as structure but need complete information)
        
        # Parse markers for AI processing
        for template in templates_loaded:
            parse_ai_instructions(template)
            identify_placeholders(template)
            extract_universal_content(template)
    
    # ==========================================
    # STEP 2: COMPREHENSIVE DISCOVERY (FROM v1.00a)
    # ==========================================
    
    #AI->H::Status: (Beginning comprehensive project discovery)
    #AI->H::Note: (Feel free to interrupt with questions or corrections)
    
    # 2.1 PROJECT IDENTIFICATION
    # --------------------------
    #AI->H::RequiredQuestion: (Let's establish project identity:
        1. Three-digit project number? (e.g., 025)
        2. Project name in UPPERCASE-HYPHENATED? (e.g., CRAFT-ALPHA)
        3. Initial version? (default: v0101a1)
    )
    
    PROJECT_NUMBER = user_response.number
    PROJECT_NAME = user_response.name  
    VERSION = user_response.version or "v0101a1"
    
    # 2.2 PROJECT PURPOSE & OBJECTIVES
    # --------------------------------
    #AI->H::RequiredQuestion: (What is the main purpose of {PROJECT_NAME}?
        What problem does it solve or opportunity does it address?)
    
    #AI->H::FollowUp: (You mentioned [key aspect]. Can you elaborate on:
        - What success looks like for this project?
        - Specific measurable outcomes?
        - What would failure look like?)
    
    #AI->H::Question: (Are there objectives that will emerge during the project?)
    
    OBJECTIVES = categorize_objectives(user_responses)
    
    # 2.3 TARGET AUDIENCE IDENTIFICATION
    # ----------------------------------
    #AI->H::RequiredQuestion: (Who will use or benefit from {PROJECT_NAME}?
        Consider both direct users and indirect beneficiaries.)
    
    #AI->H::Question: (For each audience, what is their:
        - Technical expertise level?
        - Familiarity with CRAFT?
        - Primary use case?)
    
    # 2.4 PROJECT SCOPE & CONSTRAINTS
    # -------------------------------
    #AI->H::Question: (What are the boundaries of this project?
        - Timeline constraints
        - Resource limitations
        - Technical requirements
        - Integration needs
        - Must-haves vs nice-to-haves?)
    
    # 2.5 TECHNICAL SPECIFICATIONS
    # ----------------------------
    #AI->H::Question: (Any specific technical requirements?
        - Programming languages?
        - External APIs or tools?
        - Performance requirements?
        - Security considerations?)
    
    # 2.6 PERSONA SELECTION
    # ---------------------
    #AI->H::Question: (The default persona is The Professional Assistant.
        Would you like to:
        1. Keep the default
        2. Choose a different persona
        3. Create a custom persona?)
    
    if user_response != "1":
        #AI->H::Status: (Activating CRAFT_PERSONA_MANAGER_RECIPE)
        CRAFT_PERSONA_MANAGER_RECIPE.execute({
            "action": "select" if response == "2" else "create",
            "project_context": PROJECT_NAME
        })
        #AI->H::Status: (Persona configured - returning to project creation)
    
    # 2.7 ABOUT ME SECTION (OPTIONAL)
    # -------------------------------
    #AI->H::OptionalQuestion: (Would you like to add an About Me section?
        This helps personalize AI interactions. Include:
        - Name and role?
        - Location/timezone?
        - Technical expertise?
        - CRAFT experience level?)
    
    if user_wants_about_me:
        ABOUT_ME = gather_user_info()
    
    # 2.8 PROJECT-SPECIFIC VARIABLES
    # ------------------------------
    #AI->H::Question: (Are there project-specific variables to track?
        - Configuration settings?
        - API keys or endpoints?
        - Custom parameters?
        - Business logic constants?)
    
    # 2.9 KNOWLEDGE GAP ANALYSIS
    # --------------------------
    #AI->H::Analysis: (Analyzing for knowledge gaps)
    
    
    knowledge_gaps = []
    for topic in [OBJECTIVES, TECHNICAL_SPECS, AUDIENCE]:
        if needs_research(topic):
            knowledge_gaps.append(topic)
    
    if knowledge_gaps:
        #AI->H::OptionalQuestion: (I identified potential knowledge gaps in:
            {knowledge_gaps}
            Would you like me to generate research prompts for these?
            1. Yes - Generate prompts
            2. No - Continue without)
        
        if user_response == "1":
            research_prompts = generate_research_prompts(knowledge_gaps)
    
    # ==========================================
    # STEP 3: CONTENT GENERATION WITH VALIDATION
    # ==========================================
    
    #AI->H::Status: (Generating project structure with validation)
    
    # Use SOURCE-VALID for fact checking
    for claim in project_claims:
        SOURCE_VALID_RECIPE.execute({"claim": claim})
    
    # 3.1 Generate PROJECT_META Section
    PROJECT_META = f"""
    PROJECT_ID = "CFT-PROJ-CP-{PROJECT_NUMBER}"
    PROJECT_NAME = "{PROJECT_NAME}"
    PROJECT_VERSION = "{VERSION}"
    PROJECT_CREATED = "{datetime.now()}"
    PROJECT_PHASE = "Alpha Phase 1"
    PRIMARY_GOAL = "{OBJECTIVES['primary']}"
    SUCCESS_METRICS = {OBJECTIVES['metrics']}
    """
    
    # 3.2 Generate PROJECT_INSTRUCTIONS
    PROJECT_INSTRUCTIONS = f"""
    # Global configuration for {PROJECT_NAME}
    CRAFT_MODE = "production"
    COM_ENABLED = True
    AUTO_RECIPE_DETECTION = True
    TOKEN_MONITORING = True
    PERSONA_DEFAULT = "{selected_persona}"
    """
    
    # 3.3 Generate PROJECT_VARIABLES
    PROJECT_VARIABLES = generate_variables_section(
        user_variables,
        include_com_config=True,
        include_cookbook_config=True
    )
    
    # 3.4 Generate PROJECT_FUNCTIONS
    PROJECT_FUNCTIONS = """
    # Project-specific functions
    # [Functions will be added as project develops]
    """
    
    # 3.5 Generate PROJECT_OBJECTS  
    PROJECT_OBJECTS = """
    # Project-specific objects
    # [Objects will be added as project develops]
    """
    
    # 3.6 Generate ABOUT_ME if provided
    ABOUT_ME_SECTION = ""
    if ABOUT_ME:
        ABOUT_ME_SECTION = format_about_me(ABOUT_ME)
    
    # ==========================================
    # STEP 4: TEMPLATE INTEGRATION
    # ==========================================
    
    #AI->H::Status: (Integrating with template structure)
    
    if templates_loaded:
        # Merge generated content with template structure
        PROJECT_FILE = merge_with_template(
            template=templates_loaded['project'],
            generated_content={
                "META": PROJECT_META,
                "INSTRUCTIONS": PROJECT_INSTRUCTIONS,
                "VARIABLES": PROJECT_VARIABLES,
                "FUNCTIONS": PROJECT_FUNCTIONS,
                "OBJECTS": PROJECT_OBJECTS,
                "ABOUT_ME": ABOUT_ME_SECTION
            }
        )
        
        HANDOFF_FILE = merge_with_template(
            template=templates_loaded['handoff'],
            project_info={
                "number": PROJECT_NUMBER,
                "name": PROJECT_NAME,
                "version": VERSION
            }
        )
    else:
        # Generate from scratch if no templates
        PROJECT_FILE = generate_complete_project_file()
        HANDOFF_FILE = generate_complete_handoff_file()
    
    # ==========================================
    # STEP 3: TEMPLATE PROCESSING
    # ==========================================
    
    #AI->H::Status: (Processing templates with your information)
    
    # Replace all markers with gathered information
    for template_type in ["project", "handoff"]:
        content = template_structure[template_type]["universal_content"]
        
        # Replace project identifiers
        content = content.replace("***", PROJECT_NUMBER)
        content = content.replace("[PROJECT-NAME]", PROJECT_NAME)
        content = content.replace("[VERSION]", PROJECT_VERSION)
        
        # Process each marker
        for marker in template_structure[template_type]["markers"]:
            if marker.type == "[USER-INPUT]":
                content = replace_with_user_data(content, marker, gathered_data)
            elif marker.type == "[PROJECT-SPECIFIC]":
                content = generate_project_specific(content, marker, PROJECT_GOALS)
            elif marker.type == "[PLACEHOLDER]":
                content = generate_content(content, marker)
            # [KEEP-AS-IS] sections remain unchanged
        
        processed_templates[template_type] = content
    
    # ==========================================
    # STEP 4: CONTENT GENERATION
    # ==========================================
    
    #AI->H::Status: (Generating complete project files)
    
    # 4.1 Generate PROJECT FILE
    # -------------------------
    PROJECT_FILE = generate_project_file({
        "number": PROJECT_NUMBER,
        "name": PROJECT_NAME,
        "version": PROJECT_VERSION,
        "goals": PROJECT_GOALS,
        "about_me": ABOUT_ME,
        "template": processed_templates["project"]
    })
    
    # 4.2 Generate HANDOFF FILE
    # -------------------------
    HANDOFF_FILE = generate_handoff_file({
        "number": PROJECT_NUMBER,
        "name": PROJECT_NAME,
        "version": PROJECT_VERSION,
        "template": processed_templates["handoff"]
    })
    
    # ==========================================
    # STEP 5: VALIDATION
    # ==========================================
    
    #AI->H::Status: (Validating generated files)
    
    VALIDATION_CHECKS = [
        "All markers replaced",
        "No *** placeholders remaining", 
        "No [MASTER-TEMPLATE] in output",
        "Project number consistent",
        "Version numbers match",
        "Required sections present"
    ]
    
    for check in VALIDATION_CHECKS:
        if validate(check):
            #AI->H::Check: (✓ {check})
        else:
            #AI->H::Warning: (✗ {check} - Manual review needed)
    
    # ==========================================
    # STEP 6: COMPLETE OUTPUT
    # ==========================================
    
    #AI->H::Status: (Project files ready - COMPLETE OUTPUT below)
    #AI->H::CRITICAL: (Copy everything between the delimiters exactly)
    
    print("=" * 50)
    print(f"START PROJECT FILE: CFT-PROJ-CP-{PROJECT_NUMBER}_{PROJECT_NAME}-{VERSION}.txt")
    print("=" * 50)
    print(PROJECT_FILE)  # COMPLETE file, no truncation
    print("=" * 50)
    print("END PROJECT FILE")
    print("=" * 50)
    
    print("\n\n")
    
    print("=" * 50)
    print(f"START HANDOFF FILE: CFT-PROJ-CP-{PROJECT_NUMBER}_AI-CHAT-HISTORY-{VERSION}.txt")
    print("=" * 50)
    print(HANDOFF_FILE)  # COMPLETE file, no truncation
    print("=" * 50)
    print("END HANDOFF FILE")
    print("=" * 50)
    
    # ==========================================
    # STEP 7: NEXT STEPS
    # ==========================================
    
    #AI->H::Instructions: (To complete the setup:
        1. Copy each complete file from above (between the delimiters)
        2. Save as new files with the exact filenames shown
        3. Remove the [MASTER-TEMPLATE] files from your project folder
        4. Re-run CHAT-INIT with your new files
        5. The system will recognize them as regular project files
    )
    
    #AI->H::Summary: (Created for project {PROJECT_NUMBER}:
        ✓ Customized project implementation file
        ✓ Conversation continuity file with handoff structure
        ✓ All project-specific variables configured
        ✓ About Me section personalized
        ✓ Ready for immediate use
    )
    
    #AI->H::FinalQuestion: (Do you need me to:
        - Explain any section in detail?
        - Regenerate with different information?
        - Add additional custom sections?
    )
    """
)


# =========================================================
# HELPER FUNCTIONS FOR PROJECT_CREATOR
# =========================================================


def extract_markers(content):
    """Extract all instruction markers from template"""
    import re
    patterns = [
        r'\[AI-INSTRUCTION:.*?\]',
        r'\[PLACEHOLDER:.*?\]',
        r'\[KEEP-AS-IS\]',
        r'\[USER-INPUT:.*?\]',
        r'\[PROJECT-SPECIFIC:.*?\]'
    ]
    markers = []
    for pattern in patterns:
        markers.extend(re.findall(pattern, content))
    return markers


def parse_sections(content):
    """Parse template into logical sections"""
    sections = {}
    current_section = None
    
    for line in content.split('\n'):
        if line.startswith('# ===='):
            # Section delimiter
            continue
        elif line.startswith('# '):
            # Section header
            current_section = line.strip('# ')
            sections[current_section] = []
        elif current_section:
            sections[current_section].append(line)
    
    return sections


def extract_universal(content):
    """Extract universal content marked with [KEEP-AS-IS]"""
    universal_sections = []
    in_universal = False
    
    for line in content.split('\n'):
        if '[KEEP-AS-IS]' in line:
            in_universal = True
        elif '[END-KEEP-AS-IS]' in line:
            in_universal = False
        elif in_universal:
            universal_sections.append(line)
    
    return '\n'.join(universal_sections)


def replace_with_user_data(content, marker, data):
    """Replace marker with user-provided data"""
    marker_key = marker.strip('[USER-INPUT:').strip(']')
    if marker_key in data:
        return content.replace(marker, data[marker_key])
    return content


def generate_project_specific(content, marker, goals):
    """Generate project-specific content based on goals"""
    # Generate appropriate content based on project goals
    # This would be customized based on the specific marker
    return content


def generate_content(content, marker):
    """Generate content for placeholder markers"""
    # Generate appropriate content for placeholders
    return content


# =========================================================
# END RECIPE-ID: RCP-001-004-018-PROJECT-CREATOR-v3.00a
# =========================================================






# =========================================================
# START RECIPE-ID: RCP-001-004-019-CRAFT-FRAMEWORK-UPDATER-v1.00a
# =========================================================  




CRAFT_FRAMEWORK_UPDATER_RECIPE = Recipe(
recipe_id="RCP-001-004-019-CRAFT-FRAMEWORK-UPDATER-v1.00a",
title="CRAFT Framework File Optimization and Review Tool",
description="Comprehensive analysis and optimization recommendations for the four core CRAFT framework files to maintain clarity, eliminate redundancy, and ensure optimal organization for AI understanding",
category="CAT-Foundational",
subcategory="SUBCAT-Base-Cookbook",
difficulty="advanced",
parameters={
    "project_files": {
        "type": "list",
        "required": True,
        "description": "List of the 4 CRAFT framework files to analyze",
        "example": [
            "CFT-PROJ-024_CRAFT-ALPHA-v*.txt",
            "CFT-PROJ-024_AI-CHAT-HISTORY-v*.txt",
            "CFT-FWK-SPEC-v*.txt",
            "CFT-FWK-COOKBK-CORE-v*.txt"
        ]
    },
    "analysis_depth": {
        "type": "string",
        "required": False,
        "default": "comprehensive",
        "options": ["quick", "standard", "comprehensive"],
        "description": "Level of analysis detail"
    },
    "focus_areas": {
        "type": "list",
        "required": False,
        "default": ["all"],
        "options": ["duplicates", "confusion", "migration", "recipes", "components", "all"],
        "description": "Specific areas to focus the analysis on"
    }
},


prompt_template="""
#H->AI::Directive: (Execute comprehensive CRAFT framework file analysis and optimization)
#H->AI::Context: (This recipe helps maintain CRAFT framework integrity by identifying duplicates, confusing instructions, misplaced content, and optimization opportunities across all 4 core files)


STEP 0: PRE-ANALYSIS SETUP
=========================
#AI->H::Status: (Initializing CRAFT Framework Updater analysis)
#AI->H::Note: (This analysis will generate recommendations only - you will implement changes manually)


Confirm understanding of file purposes:
1. PROJECT IMPLEMENTATION: Project-specific CRAFT implementation
2. CONVERSATION CONTINUITY: Handoff system for session continuity
3. FRAMEWORK SPECIFICATION: Core CRAFT rules and structures
4. CORE COOKBOOK: Base recipes for framework functionality


STEP 1: DUPLICATE DETECTION ANALYSIS
===================================
#AI->H::Status: (Scanning all 4 files for duplicate content)


Analyze for:
- Exact text matches (>20 words identical)
- Semantic duplicates (same meaning, different wording)
- Similar recipe/function definitions
- Repeated instructions across files


#AI->H::Report::Duplicates: (
Priority: [CRITICAL/HIGH/MEDIUM/LOW]
File 1: [filename]
Location 1: [section/line reference]
File 2: [filename]
Location 2: [section/line reference]
Duplicate Type: [exact/semantic/structural]
Content Preview: [first 50 characters]
Recommendation: [consolidate to X file / remove from Y / create recipe]
Justification: [why this change improves the framework]
)


[Repeat for each duplicate found]


#AI->H::Summary::DuplicateCount: ([X] duplicates found across all files)


STEP 2: CONFUSION POINT IDENTIFICATION
=====================================
#AI->H::Status: (Analyzing instructions for mainstream AI clarity)
#AI->H::Context: (Identifying content that may confuse less advanced AI models)


Check for:
- Contradictory directives
- Ambiguous references
- Missing context
- Overly complex nested structures
- References to non-existent components
- Instructions requiring advanced inference


#AI->H::Report::ConfusionPoint: (
Priority: [CRITICAL/HIGH/MEDIUM/LOW]
File: [filename]
Location: [section/line reference]
Issue Type: [contradiction/ambiguity/missing-context/complexity/broken-reference]
Problematic Content: [the confusing instruction]
Why Confusing: [explanation of the issue]
Suggested Revision: [clearer alternative wording]
Impact: [how this affects AI understanding]
)


[Repeat for each confusion point]


#AI->H::Summary::ConfusionCount: ([X] potential confusion points identified)


STEP 3: CONTENT MIGRATION ANALYSIS
==================================
#AI->H::Status: (Identifying misplaced content across files)
#AI->H::Context: (Suggesting optimal file placement for each content type)


Migration patterns to check:
- Handoff instructions → CONVERSATION CONTINUITY FILE
- Global rules/specs → FRAMEWORK SPECIFICATION
- Reusable operations → COOKBOOK as recipes
- Project configs → PROJECT IMPLEMENTATION FILE
- Generic templates → FRAMEWORK SPECIFICATION
- Session management → CONVERSATION CONTINUITY FILE


#AI->H::Report::MigrationCandidate: (
Priority: [HIGH/MEDIUM/LOW]
Current File: [filename]
Current Location: [section/line reference]
Content Type: [handoff/rule/operation/config/template]
Suggested File: [target filename]
Suggested Section: [where in target file]
Reason: [why this location is more appropriate]
Dependencies: [what else needs to move with it]
)


[Repeat for each migration candidate]


#AI->H::Summary::MigrationCount: ([X] content pieces could be better organized)


STEP 4: RECIPE CANDIDATE IDENTIFICATION
======================================
#AI->H::Status: (Identifying functionality that should become recipes)
#AI->H::Context: (Finding reusable patterns for recipe conversion)


Criteria for recipe conversion:
- Used multiple times across sessions
- Complex multi-step processes (>50 lines)
- High reusability potential
- Significant token-saving opportunity
- Standardizable workflow


#AI->H::Report::RecipeCandidate: (
Priority: [HIGH/MEDIUM/LOW]
Current File: [filename]
Current Location: [section/line reference]
Functionality: [what it does]
Current Length: [line count]
Reuse Frequency: [estimated uses per project]
Token Savings: [estimated percentage reduction]
Suggested Recipe Name: [RCP-XXX-XXX-XXX-NAME]
Recipe Category: [which cookbook category]
Implementation Complexity: [easy/moderate/complex]
)


[Repeat for each recipe candidate]


#AI->H::Summary::RecipeCandidateCount: ([X] functions could become recipes)


STEP 5: COMPONENT CONVERSION ANALYSIS
====================================
#AI->H::Status: (Identifying content for CRAFT component conversion)
#AI->H::Context: (Finding project content that fits OOP-style components)


Analyze for conversion to:
- PROJECT_META: Version tracking, identification
- PROJECT_INSTRUCTIONS: Global rules, configuration
- PROJECT_VARIABLES: Constants, settings
- PROJECT_FUNCTIONS: Reusable operations
- PROJECT_OBJECTS: Class definitions, templates


#AI->H::Report::ComponentCandidate: (
Priority: [HIGH/MEDIUM/LOW]
Current File: [filename]
Current Format: [how it's currently structured]
Suggested Component: [META/INSTRUCTIONS/VARIABLES/FUNCTIONS/OBJECTS]
Component Name: [proposed name]
Current Content: [brief description]
Conversion Benefits: [why this improves organization]
Sample Structure: [example of converted format]
)


#AI->H::Question: (Would you like me to provide the full converted component structure for [component name]?)


[Wait for response, then provide if requested]


#AI->H::Summary::ComponentCount: ([X] items suitable for component conversion)


STEP 6: COMPREHENSIVE IMPLEMENTATION PLAN
========================================
#AI->H::Status: (Creating prioritized implementation plan)
#AI->H::Context: (Organizing all findings into actionable steps)


#AI->H::Report::ImplementationPlan: (
PHASE 1: CRITICAL FIXES (Address immediately)
============================================
[List all CRITICAL priority items from steps 1-5]
Estimated time: [X sessions]


PHASE 2: HIGH PRIORITY OPTIMIZATIONS
===================================
[List all HIGH priority items organized by type]
Estimated time: [X sessions]


PHASE 3: MEDIUM PRIORITY IMPROVEMENTS
====================================
[List all MEDIUM priority items organized by file]
Estimated time: [X sessions]


PHASE 4: LOW PRIORITY ENHANCEMENTS
=================================
[List all LOW priority items as optional]
Estimated time: [X sessions]
)


#AI->H::Question: (Which phase would you like to begin with? I recommend starting with Phase 1 critical fixes.)


STEP 7: GUIDED IMPLEMENTATION
============================
#AI->H::Status: (Ready to guide implementation of selected phase)


[Based on user selection, provide detailed steps]


For each change:
1. #AI->H::Instruction: (Copy this exact text from [source])
2. #AI->H::ShowOriginal: ([original text block])
3. #AI->H::ShowRevised: ([revised text block])
4. #AI->H::Instruction: (Replace in [filename] at [location])
5. #AI->H::ValidationCheck: (Confirm: Has the change been made?)


[Continue through all changes in selected phase]


#AI->H::Status: (Phase [X] implementation complete)
#AI->H::Question: (Ready to proceed to next phase or would you like to test current changes first?)


FINAL SUMMARY
============
#AI->H::Report::OptimizationSummary: (
Total Issues Found: [X]
- Duplicates: [X]
- Confusion Points: [X]
- Migration Candidates: [X]
- Recipe Candidates: [X]
- Component Candidates: [X]


Estimated Token Savings: [X]% reduction
Clarity Improvement: [description of main improvements]
Organization Enhancement: [how structure is clearer]


Next Recommended Action: [specific next step]
)


#AI->H::Note: (Save this analysis for reference during implementation)
"""








# =========================================================
# END RECIPE-ID: RCP-001-004-019-CRAFT-FRAMEWORK-UPDATER-v1.00a
# =========================================================  




# =========================================================
# START RECIPE-ID: RCP-001-004-020-CRAFT-PERSONA-MGR-v1.00a
# =========================================================
"""
CRAFT_PERSONA_MANAGER_RECIPE = Recipe(
    recipe_id="RCP-001-004-020-CRAFT-PERSONA-MGR-v1.00a",
    title="CRAFT Persona Manager - Dynamic AI Personality Adaptation",
    description="Manages AI persona switching to optimize communication based on task context, maintaining user consent and session continuity",
    category="CAT-Foundational",
    subcategory="SUBCAT-Base-Cookbook",
    difficulty="medium",
    
    parameters={
        "trigger_context": {
            "type": "string",
            "required": True,
            "description": "What triggered the persona evaluation (user_request, task_detection, manual_switch)"
        },
        "current_task": {
            "type": "string",
            "required": True,
            "description": "Description of the current task or conversation context"
        },
        "current_persona": {
            "type": "object",
            "required": True,
            "description": "The currently active persona object"
        },
        "user_preferences": {
            "type": "dict",
            "required": False,
            "default": {},
            "description": "Any known user preferences for persona behavior"
        }
    },
    
    prompt_template='''
    #H->AI::Directive: (Execute persona management workflow with user consent)
    #H->AI::Context: (Triggered by: {trigger_context})
    
    STEP 1: PERSONA EVALUATION
    ==========================
    #AI->H::Status: (Analyzing task context for optimal persona match)
    
    Current Context Analysis:
    - Task: {current_task}
    - Active Persona: {current_persona.name}
    - Trigger: {trigger_context}
    
    Available Personas (Core Set):
    1. The Professional Assistant (Default)
    2. The Creative Writing Coach
    3. The Tech Support Specialist
    4. The Data Analyst
    5. The Project Manager
    6. The Language Teacher
    7. The Research Assistant
    8. The Code Mentor
    9. The Business Strategist
    10. The Wellness Coach
    
    Evaluation Criteria:
    - Task alignment score (0-100)
    - User communication style match
    - Domain expertise relevance
    - Formality level appropriateness
    - Expected interaction duration
    
    #AI->H::Analysis: (Evaluating each persona against current task)
    
    [For each relevant persona, calculate:]
    - Task Match Score: {score}/100
    - Key Strengths: {list}
    - Potential Benefits: {list}
    
    Recommendation: {recommended_persona}
    Confidence: {confidence_level}%
    
    STEP 2: PERSONA PROPOSAL
    ========================
    IF recommended_persona != current_persona AND confidence > 70:
        
        #AI->H::PersonaSwitch: (Proposing persona change from {current_persona.name} to {recommended_persona.name})
        
        Proposal Format:
        ┌─────────────────────────────────────────┐
        │ 🎭 PERSONA OPTIMIZATION DETECTED        │
        ├─────────────────────────────────────────┤
        │ Current Task: {task_summary}            │
        │ Current Persona: {current_persona.name} │
        │ Suggested: {recommended_persona.name}   │
        │                                         │
        │ Benefits of switching:                  │
        │ • {benefit_1}                          │
        │ • {benefit_2}                          │
        │ • {benefit_3}                          │
        └─────────────────────────────────────────┘
        
        #AI->H::ProposedPersona: ({recommended_persona.proposal_text})
        
        #AI->H::Question: (Would you like me to switch to the {recommended_persona.name} persona for this task?)
        
        [WAIT FOR USER RESPONSE]
        
    ELSE:
        #AI->H::Note: (Current persona {current_persona.name} is well-suited for this task)
        RETURN current_persona
    
    STEP 3: CLARIFICATION & CALIBRATION
    ====================================
    IF user_accepts_switch:
        
        #AI->H::Status: (Switching to {recommended_persona.name} persona)
        #AI->H::PersonaSwitch: (Activated: {recommended_persona.name})
        
        Context Calibration Questions:
        
        General Questions:
        #AI->H::ClarifyingQuestion: ({recommended_persona.general_calibration_question})
        
        Persona-Specific Questions:
        #AI->H::RequiredQuestion: ({recommended_persona.specific_calibration_question})
        
        #AI->H::OptionalQuestion: (Are there any specific constraints or preferences I should keep in mind while in this role?)
        
        [WAIT FOR USER RESPONSES]
        
        #AI->H::Status: (Persona calibration complete)
        
    STEP 4: PERSONA ACTIVATION
    ==========================
    
    Update Session State:
    SESSION.ACTIVE_PERSONA = {recommended_persona}
    SESSION.PERSONA_PARAMETERS = {
        "tone": {recommended_persona.tone},
        "formality": {recommended_persona.formality_level},
        "communication_style": {recommended_persona.communication_patterns},
        "domain_focus": {recommended_persona.expertise_areas},
        "interaction_mode": {recommended_persona.interaction_style}
    }
    
    #AI->H::Confirmation: (Now operating as {recommended_persona.name}. {recommended_persona.activation_message})
    
    STEP 5: HANDOFF PREPARATION
    ===========================
    
    Prepare Persona State for Handoff:
    HANDOFF.PERSONA_STATE = {
        "active_persona": {recommended_persona.id},
        "activation_time": {timestamp},
        "trigger_context": {trigger_context},
        "calibration_responses": {user_responses},
        "performance_notes": {any_relevant_observations}
    }
    
    #AI->H::Note: (Persona state prepared for session handoff)
    
    # PERSONA OBJECT DEFINITIONS
    # =========================
    
    PERSONA_1_PROFESSIONAL = {
        "id": "professional-assistant",
        "name": "The Professional Assistant",
        "popularity_score": 90,
        "description": "Handles business communications, scheduling, and formal interactions with efficiency and reliability",
        "tone": "professional, courteous, efficient",
        "formality_level": "high",
        "communication_patterns": [
            "Clear, concise language",
            "Bullet points for clarity",
            "Action-oriented statements",
            "Time-conscious responses"
        ],
        "expertise_areas": ["business", "administration", "communication", "scheduling"],
        "interaction_style": "task-focused",
        "proposal_text": "I can adopt a more professional business communication style to help with your administrative and business tasks more effectively. This will ensure our interaction maintains corporate standards while maximizing efficiency.",
        "general_calibration_question": "What is the primary business objective we're working toward?",
        "specific_calibration_question": "What level of formality is appropriate for your organization - startup casual or enterprise formal?",
        "activation_message": "I'll maintain a professional, efficient approach focused on achieving your business objectives."
    }
    
    # Additional persona definitions follow similar structure...
    
    #H->AI::OnError: (If persona switch fails, maintain current persona and log error)
    #H->AI::OnCancel: (If user declines switch, acknowledge and continue with current persona)
    '''
)


# USAGE EXAMPLES:
# ==============


# Triggered by user request:
execute_persona = CRAFT_PERSONA_MANAGER_RECIPE.execute({
    "trigger_context": "user_request",
    "current_task": "I need help writing a fantasy novel",
    "current_persona": SESSION.ACTIVE_PERSONA
})


# Triggered by CRAFT-OPERATIONS-MANAGER detection:
execute_persona = CRAFT_PERSONA_MANAGER_RECIPE.execute({
    "trigger_context": "task_detection",
    "current_task": "User is debugging Python code with multiple errors",
    "current_persona": SESSION.ACTIVE_PERSONA,
    "user_preferences": {"prefers_detailed_explanations": True}
})
"""




# =========================================================
# END RECIPE-ID: RCP-001-004-020-CRAFT-PERSONA-MGR-v1.00a
# =========================================================  






=========================================================
START RECIPE-ID: RCP-001-001-021-ULT-PROMPT-MGR-v1.00a
=========================================================
pythonULT_PROMPT_MGR_RECIPE = Recipe(
    recipe_id="RCP-001-001-021-ULT-PROMPT-MGR-v1.00a",
    title="UltraPrompt Interactive Builder and Manager",
    description="Guides users through building Richard Ketelsen's proven 10-part UltraPrompt framework interactively. Assists with template selection, accepts partial completions, and produces a complete prompt ready for any AI chat. Parts 9-10 are optional based on task needs.",
    category="CAT-001",
    subcategory="SUBCAT-Core",
    difficulty="medium",
    
    parameters={
        "user_name": {
            "type": "string",
            "required": False,
            "default": "Richard",
            "description": "User's name for personalized interaction"
        },
        "initial_purpose": {
            "type": "string",
            "required": False,
            "default": "",
            "description": "Initial stated purpose to help guide the process"
        },
        "existing_parts": {
            "type": "dict",
            "required": False,
            "default": {},
            "description": "Any pre-completed sections to incorporate"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Guide user through building 10-part UltraPrompt interactively)
    #H->AI::Context: (This is Richard Ketelsen's proven prompt framework with thousands of uses)
    #H->AI::Constraint: (Never make up information - help user build it themselves)
    #H->AI::Structure: (Track progress with PROGRESS_TRACKER throughout)
    
    # INITIALIZATION
    # =============
    #AI->H::Status: (Initializing UltraPrompt Interactive Builder)
    #AI->H::RecipeExecuting: (AUTO-EXECUTING: PROGRESS_TRACKER_RECIPE)
    
    Execute PROGRESS_TRACKER_RECIPE with:
    - total_steps: 10
    - step_names: ["Template Selection", "Personal Introduction", "Content/Purpose", 
                   "About Audience", "Content Goals", "AI Role", "Content Source", 
                   "Inspirations", "Constraints", "Visuals (Optional)", "Related Content (Optional)"]
    
    # STEP 1: TEMPLATE SELECTION
    # ==========================
    #AI->H::Progress: (Step 1 of 10: Template Selection)
    
    Hello {user_name}, would you like to use 1 of the following templates or create a custom prompt?
    
    **Available Templates:**
    1. **KETELSEN.AI-STD-BLOG-POST-01** - For AI experimentation and prompt engineering content
    2. **CRAFTSHOP.AI-STD-BLOG-POST-01** - For crafting and creative DIY content  
    3. **AICOOKBOOK.AI-STD-BLOG-POST-01** - For reliable, recipe-style AI solutions
    4. **CUSTOM** - Build from scratch with the core 8 parts (9-10 optional)
    
    #AI->H::RequiredQuestion: (Please respond with the template name or "CUSTOM")
    
    [Wait for user response]
    
    IF template selected:
        LOAD template defaults for sections 1, 2, 5, 7, 8
        #AI->H::Note: (Template loaded - I'll use defaults for sections 1, 2, 5, 7, and 8)
        #AI->H::Note: (You'll need to provide sections 3, 4, 6, and optionally 9-10)
    ELSE IF "CUSTOM":
        #AI->H::Note: (Building custom prompt - I'll guide you through each section)
        NO defaults loaded
    
    # STEP 2: PERSONAL INTRODUCTION (Section 1)
    # =========================================
    #AI->H::Progress: (Step 2 of 10: Personal Introduction)
    
    IF template loaded AND has default for section 1:
        #AI->H::Note: (Using template default for Personal Introduction)
        Display default content
        #AI->H::Question: (Would you like to use this default or provide your own? Reply "USE DEFAULT" or provide new text)
    ELSE:
        #AI->H::RequiredQuestion: (Please provide your personal introduction - who you are, your background, and relevant expertise)
        
    [Store response as SECTION_1]
    
    # STEP 3: CONTENT/WEBSITE PURPOSE (Section 2)
    # ===========================================
    #AI->H::Progress: (Step 3 of 10: Content/Website Purpose)
    
    IF template loaded AND has default for section 2:
        #AI->H::Note: (Using template default for Content/Website Purpose)
        Display default content
        #AI->H::Question: (Would you like to use this default or provide your own?)
    ELSE:
        #AI->H::RequiredQuestion: (Describe the website/platform and its intended purpose for context)
    
    [Store response as SECTION_2]
    
    # STEP 4: ABOUT THE AUDIENCE (Section 3)
    # ======================================
    #AI->H::Progress: (Step 4 of 10: About the Audience and Website)
    #AI->H::Caution: (This section requires your specific input - no defaults used)
    
    #AI->H::Note: (For this critical section, you'll provide:)
    - Target Audience demographics and psychographics
    - Pain Points & Unique Value Proposition
    - Competitive Edge
    - Elevator Pitch
    
    #AI->H::RequiredQuestion: (Please provide your audience and website details. You can use a specialized recipe from CONTENT-AND-PROMO cookbook if preferred, or provide the information directly)
    
    [Store response as SECTION_3]
    
    # STEP 5: CONTENT GOALS (Section 4)
    # =================================
    #AI->H::Progress: (Step 5 of 10: Content Goals)
    
    #AI->H::RequiredQuestion: (What are the specific objectives you want to achieve with this content/prompt?)
    
    Help user articulate:
    - Primary objective
    - Secondary goals
    - Success metrics if applicable
    - Specific deliverables expected
    
    [Store response as SECTION_4]
    
    # STEP 6: ROLE OF THE AI (Section 5)
    # ==================================
    #AI->H::Progress: (Step 6 of 10: Role of the AI)
    
    IF template loaded AND has default for section 5:
        #AI->H::Note: (Using template default for AI Role)
        Display: "You are an expert in creating prompts for ChatGPT, Google GEMINI, Anthropic Claude..."
        #AI->H::Question: (Use this default expert role or define a custom role?)
    ELSE:
        #AI->H::RequiredQuestion: (What role should the AI assume? What expertise should it embody?)
    
    [Store response as SECTION_5]
    
    # STEP 7: CONTENT SOURCE (Section 6)
    # ==================================
    #AI->H::Progress: (Step 7 of 10: Content Source)
    
    #AI->H::RequiredQuestion: (What sources should the AI use to achieve the objectives? Examples: "any resources needed", "provided documents", "web research", etc.)
    
    [Store response as SECTION_6]
    
    # STEP 8: INSPIRATIONS (Section 7)
    # ================================
    #AI->H::Progress: (Step 8 of 10: Inspirations for Content)
    
    IF template loaded AND has default for section 7:
        Display default inspiration guidance
        #AI->H::Question: (Use template inspiration style or provide custom?)
    ELSE:
        #AI->H::RequiredQuestion: (What style/tone inspirations should guide the AI? Reference publications, writing styles, or specific examples)
    
    [Store response as SECTION_7]
    
    # STEP 9: CONSTRAINTS (Section 8)
    # ===============================
    #AI->H::Progress: (Step 9 of 10: Constraints)
    
    IF template loaded AND has default for section 8:
        Display default constraints
        #AI->H::Question: (Use these constraints or modify?)
    ELSE:
        #AI->H::RequiredQuestion: (Any specific constraints or things to avoid?)
    
    Common constraint categories:
    - Output formatting restrictions
    - Content to avoid
    - Factual accuracy requirements
    - Length limitations
    
    [Store response as SECTION_8]
    
    # STEP 10: OPTIONAL SECTIONS CHECK
    # ================================
    #AI->H::Progress: (Step 10 of 10: Optional Sections)
    
    #AI->H::Question: (Would you like to include the optional sections? 
    - Section 9: Ideas for visuals
    - Section 10: Related Stories/Content
    Reply "BOTH", "VISUALS ONLY", "RELATED ONLY", or "NONE")
    
    IF includes Section 9:
        #AI->H::RequiredQuestion: (Describe visual requirements or ideas. Include format specifications if needed)
        [Store as SECTION_9]
    
    IF includes Section 10:
        #AI->H::RequiredQuestion: (Describe any related content, series information, or helpful URLs)
        [Store as SECTION_10]
    
    # FINAL ASSEMBLY
    # =============
    #AI->H::Status: (Assembling complete UltraPrompt)
    #AI->H::Progress: (Complete: 10 of 10 steps finished)
    
    **YOUR COMPLETE ULTRAPROMPT:**
    
    ```
    # 01 - INITIAL PROMPT
    
    PROMPT: "Hi, we will work together to [task description]. To begin, I will provide a [8/9/10]-part prompt that will describe the following:
    
    1. Personal Introduction: Who I am.
    2. Content/Website Purpose: The context for which this will be created.
    3. About the Audience: Target Audience, Pain Points & Unique Value Proposition, Competitive Edge and Elevator Pitch.
    4. Content Goals: The objectives to achieve.
    5. Role of the A.I.: The expected role that you, the A.I. chat service, should assume.
    6. Content Source: The source from which to derive information.
    7. Inspirations: Guidance for understanding the type of output to create.
    8. Constraints: Any specific constraints or aspects to avoid.
    [IF Section 9]: 9. Ideas for visuals: Visual elements to consider.
    [IF Section 10]: 10. Related Stories/Content: Series context and references.
    
    1) [SECTION_1]
    
    2) [SECTION_2]
    
    3) [SECTION_3]
    
    4) [SECTION_4]
    
    5) [SECTION_5]
    
    6) [SECTION_6]
    
    7) [SECTION_7]
    
    8) [SECTION_8]
    
    [IF SECTION_9]: 9) [SECTION_9]
    
    [IF SECTION_10]: 10) [SECTION_10]
    
    Before continuing the next set of instructions, please list any items that need clarification. If there are no questions, please respond with "READY".
    ```
    
    #AI->H::Status: (UltraPrompt complete and ready to copy)
    #AI->H::Note: (This prompt has been assembled interactively and is ready for use in any AI chat)
    
    #AI->H::OptionalQuestion: (Would you like me to save this as a named template for future use?)
    
    #H->AI::OnError: (If user needs to restart, maintain any completed sections in memory)
    """
)


# TEMPLATE DEFINITIONS (Referenced by recipe)
# ===========================================


ULTRAPROMPT_TEMPLATES = {
    "KETELSEN.AI-STD-BLOG-POST-01": {
        "section_1": "Based in Minneapolis, MN, USA, I am a professional in Computer Science and Graphic Design. I work for a Fortune 100 Company as a Senior Cybersecurity Incident Responder...",
        "section_2": "The website is located at www.ketelsen.ai and is part of the blog section. Ketelsen.ai is An Ongoing AI prompt crafting Experiment...",
        "section_5": 'You are "an expert in creating prompts for ChatGPT, Google GEMINI, Anthropic Claude and other similar Gen AI Tools"...',
        "section_7": "The content style should be fun, entertaining and informative. Since the target audience for this site is entrepreneurs...",
        "section_8": "Please do not use any text styles in the output/responses beyond the standard bold type, italic type, monospace type, and standard type..."
    },
    "CRAFTSHOP.AI-STD-BLOG-POST-01": {
        "section_1": "Based in Minneapolis, MN, USA, I am a professional in Computer Science and Graphic Design...",
        "section_2": "The website is located at www.craftshop.ai",
        "section_5": 'You are "an expert in creating prompts for ChatGPT, Google GEMINI, Anthropic Claude and other similar Gen AI Tools"...',
        "section_7": "The content style should be fun, entertaining and informative...",
        "section_8": "Please do not use any text styles in the output/responses beyond the standard bold type..."
    },
    "AICOOKBOOK.AI-STD-BLOG-POST-01": {
        "section_1": "Based in Minneapolis, MN, USA, I am a professional in Computer Science and Graphic Design...",
        "section_2": "The A.I. Cookbook is located at aicookbook.ai and it is more than just a manual...",
        "section_5": 'You are "an expert in creating prompts for ChatGPT, Google GEMINI, Anthropic Claude and other similar Gen AI Tools"...',
        "section_7": "The content style should be fun, entertaining and informative...",
        "section_8": "Please do not make up any fake information..."
    }
}


# USAGE NOTES:
# ===========
# This recipe guides users through building the proven UltraPrompt framework
# that Richard Ketelsen has used thousands of times. It provides template
# options for common use cases while allowing full customization. The recipe
# ensures users build their own information rather than having AI generate it,
# maintaining the authenticity and specificity that makes UltraPrompts effective.
#
# The recipe automatically tracks progress and produces a complete, copyable
# prompt ready for use in any AI chat system.
=========================================================
END RECIPE-ID: RCP-001-001-021-ULT-PROMPT-MGR-v1.00a
=========================================================






# =========================================================
# RECIPE-ID: RCP-001-001-022-CODE-EDITOR-v1.00a
# =========================================================


CODE_EDITOR_RECIPE = Recipe(
    recipe_id="RCP-001-001-022-CODE-EDITOR-v1.00a",
    title="Systematic Code Review and Bug Detection",
    description="Activates meticulous code editor persona to review and fix bugs in any CRAFT framework code",
    category="CAT-001-CORE",
    subcategory="SUBCAT-001-Foundational",
    difficulty="beginner",
    version="1.00a",
    
    parameters={
        "target_code": {
            "type": "string",
            "required": False,
            "description": "Specific artifact ID, recipe name, or code section to review. If not specified, will ask."
        },
        "review_focus": {
            "type": "string",
            "required": False,
            "default": "comprehensive",
            "description": "Optional focus area: bugs, consistency, optimization, or comprehensive"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Activate Code Editor mode for systematic code review)
    #H->AI::Context: (Review CRAFT framework code for bugs, errors, and inconsistencies)
    
    # ==========================================
    # STEP 1: ROLE ACTIVATION
    # ==========================================
    
    #AI->H::Status: (Assuming role of Code Editor for comprehensive review)
    #AI->H::PersonaSwitch: (Activating Code Editor - meticulous, detail-oriented, bug-hunter)
    #AI->H::Note: (I'll systematically review code for issues and fix them directly)
    
    # ==========================================
    # STEP 2: TARGET IDENTIFICATION
    # ==========================================
    
    if not target_code:
        #AI->H::RequiredQuestion: (Which code should I review? Please specify:
            - An artifact ID (e.g., "chat_init_enhanced")
            - A recipe name (e.g., "PROJECT_CREATOR_RECIPE")
            - A description (e.g., "the most recent recipe")
            - "all artifacts" to review everything in this session
        )
        # Wait for user response
        target_code = user_response
    
    #AI->H::Status: (Reviewing: {target_code})
    
    # ==========================================
    # STEP 3: SYSTEMATIC REVIEW
    # ==========================================
    
    #AI->H::Note: (Scanning for common issue patterns)
    
    REVIEW_CHECKLIST = [
        # Syntax and Structure
        "Version consistency in comments and IDs",
        "Proper closing tags/comments",
        "Correct indentation and formatting",
        "String formatting consistency",
        
        # Logic and Flow
        "Undefined variables",
        "Missing error handling",
        "Unreachable code",
        "Redundant operations",
        
        # CRAFT-Specific
        "Recipe ID format (RCP-XXX-YYY-ZZZ-NAME-vX.XXa)",
        "Comment format (H->AI, AI->H)",
        "Proper parameter definitions",
        "Category consistency",
        
        # Best Practices
        "Hardcoded values that should be variables",
        "Missing initialization",
        "Inconsistent naming conventions",
        "Missing validation checks"
    ]
    
    issues_found = []
    
    for check_item in REVIEW_CHECKLIST:
        result = analyze_code_for(check_item, target_code)
        if result.has_issue:
            issues_found.append(result)
            #AI->H::IssueFound: ({check_item}: {result.description})
    
    # ==========================================
    # STEP 4: ISSUE FIXING
    # ==========================================
    
    if issues_found:
        #AI->H::Status: (Found {len(issues_found)} issues - fixing now)
        
        for issue in issues_found:
            #AI->H::BugFound: ({issue.description})
            
            # Fix directly in artifact if possible
            if issue.can_auto_fix and issue.artifact_id:
                old_code = issue.problematic_code
                new_code = issue.fixed_code
                
                # Apply fix using artifact update
                apply_fix(issue.artifact_id, old_code, new_code)
                
                #AI->H::BugFixed: ({issue.type} corrected)
                #AI->H::Change: (
                    Before: {summarize(old_code)}
                    After: {summarize(new_code)}
                )
            else:
                #AI->H::ManualFixNeeded: ({issue.description}
                    Suggested fix: {issue.suggestion}
                )
    else:
        #AI->H::Success: (No issues found - code appears clean)
    
    # ==========================================
    # STEP 5: REVIEW SUMMARY
    # ==========================================
    
    #AI->H::Summary: (Code review complete)
    
    if issues_found:
        #AI->H::Report: (
            Total issues found: {len(issues_found)}
            Auto-fixed: {count_fixed}
            Manual review needed: {count_manual}
        )
        
        # Categorize by severity
        critical = [i for i in issues_found if i.severity == "critical"]
        warnings = [i for i in issues_found if i.severity == "warning"]
        info = [i for i in issues_found if i.severity == "info"]
        
        if critical:
            #AI->H::Critical: ({len(critical)} critical issues fixed)
        if warnings:
            #AI->H::Warning: ({len(warnings)} warnings addressed)
        if info:
            #AI->H::Info: ({len(info)} minor improvements made)
    
    # ==========================================
    # STEP 6: VERIFICATION
    # ==========================================
    
    #AI->H::Status: (Running verification pass)
    
    # Quick re-scan to ensure fixes didn't introduce new issues
    verification_issues = quick_scan(target_code)
    
    if verification_issues:
        #AI->H::Warning: (New issues detected after fixes - reviewing)
        # Recursive fix attempt
        fix_verification_issues(verification_issues)
    else:
        #AI->H::Confirmed: (All fixes verified - code is clean)
    
    # ==========================================
    # STEP 7: RETURN TO NORMAL MODE
    # ==========================================
    
    #AI->H::PersonaSwitch: (Returning to previous persona)
    #AI->H::Complete: (Code review finished)
    
    #AI->H::Question: (Would you like me to:
        1. Review additional code?
        2. Explain any of the fixes made?
        3. Continue with regular tasks?
    )
    """
)


# =========================================================
# HELPER FUNCTIONS FOR CODE-EDITOR
# =========================================================


def analyze_code_for(check_item, code):
    """Analyze code for specific issue pattern"""
    # Pattern matching logic for each check item
    # Returns result object with:
    # - has_issue: boolean
    # - description: what was found
    # - severity: critical/warning/info
    # - can_auto_fix: boolean
    # - problematic_code: the issue
    # - fixed_code: the solution
    pass


def apply_fix(artifact_id, old_code, new_code):
    """Apply fix to artifact using update mechanism"""
    # Use artifact update to apply the fix
    # Handle update limits (max 4 per message)
    pass


def summarize(code):
    """Create brief summary of code change"""
    # Return concise description of the code
    # Useful for showing before/after
    pass


def quick_scan(code):
    """Fast verification scan after fixes"""
    # Lightweight check for new issues
    # Focus on critical problems only
    pass


def fix_verification_issues(issues):
    """Handle issues found during verification"""
    # Attempt to fix new issues
    # Prevent infinite loops
    pass


def count_by_type(issues, fix_type):
    """Count issues by fix status"""
    # Helper for summary statistics
    pass


# =========================================================
# RECIPE METADATA
# =========================================================


# Author: CRAFT Framework Team
# Created: 2025-08-09
# Category: Core Framework Operations
# Tags: code-review, debugging, quality-assurance


# =========================================================
# USAGE EXAMPLES
# =========================================================


# Example 1: Review specific artifact
CODE_EDITOR_RECIPE.execute({
    "target_code": "chat_init_enhanced"
})


# Example 2: Review most recent code
CODE_EDITOR_RECIPE.execute({
    "target_code": "the most recent recipe created"
})


# Example 3: Let AI ask what to review
CODE_EDITOR_RECIPE.execute({})


# Example 4: Focus on specific issues
CODE_EDITOR_RECIPE.execute({
    "target_code": "PROJECT_CREATOR_RECIPE",
    "review_focus": "consistency"
})


# =========================================================
# EXPECTED BEHAVIOR
# =========================================================


"""
1. Activates meticulous Code Editor persona
2. Identifies target code (asks if not specified)
3. Systematically reviews for bugs and issues
4. Fixes issues directly in artifacts
5. Provides clear summary of changes
6. Verifies fixes didn't introduce new problems
7. Returns to previous persona


The recipe handles:
- Version mismatches
- Undefined variables  
- Missing error handling
- Hardcoded values
- Format inconsistencies
- CRAFT-specific patterns
- And more...


All fixes are applied directly to artifacts when possible,
with clear reporting of what was changed and why.
"""


# =========================================================
# END RECIPE-ID: RCP-001-001-022-CODE-EDITOR-v1.00a
# =========================================================




# =========================================================
# START RECIPE-ID: RCP-001-001-023-RECIPE-CHEATSHEET-v1.00a
# =========================================================


RECIPE_CHEATSHEET_RECIPE = Recipe(
    recipe_id="RCP-001-001-023-RECIPE-CHEATSHEET-v1.00a",
    title="CRAFT Recipe Cheatsheet - Complete Catalog and Quick Reference",
    description="Comprehensive catalog of all CRAFT recipes across all cookbooks with explanations of why each exists, their role in the framework, and example executions",
    category="CAT-001",
    subcategory="SUBCAT-General",
    difficulty="easy",
    version="1.00a",
    
    parameters={
        "cookbook_filter": {
            "type": "string",
            "required": False,
            "default": "all",
            "options": ["all", "core", "content", "specific_recipe"],
            "description": "Filter to show recipes from specific cookbook"
        },
        "output_format": {
            "type": "string",
            "required": False,
            "default": "detailed",
            "options": ["detailed", "compact", "single_recipe"],
            "description": "Level of detail in output"
        },
        "recipe_id": {
            "type": "string",
            "required": False,
            "description": "Specific recipe ID to explain (for single_recipe mode)"
        }
    },
    
    prompt_template="""
    #H->AI::Directive: (Generate comprehensive recipe catalog or explain specific recipe)
    #H->AI::Context: (Reference all loaded cookbook files for complete listing)
    
    Based on {output_format} mode:
    - If "detailed": Show all recipes with full explanations
    - If "compact": Show recipe list with one-line descriptions
    - If "single_recipe": Explain the specified {recipe_id} in depth
    
    Include for each recipe (detailed mode):
    1. Recipe ID and Title
    2. Why It Exists (problem it solves)
    3. Why It's in its category (CORE vs CONTENT)
    4. Role in CRAFT Framework
    5. Example execution with parameters
    """
)


# =========================================================
# END RECIPE-ID: RCP-001-001-023-RECIPE-CHEATSHEET-v1.00a
# =========================================================